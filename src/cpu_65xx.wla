; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; cpu_65xx.wla : macros for 6502/6510/65C02
;===============================================================================
.DEF    CPU_VECTOR_NMI  $fffa   ; Non-Maskable-Interrupt vector
.DEF    CPU_VECTOR_RST  $fffc   ; cold-reset vector
.DEF    CPU_VECTOR_IRQ  $fffe   ; interrupt vector

.DEF    CPU_LDA         $a9     ; opcode for `LDA # $nn`
.DEF    CPU_LDA_ZP      $a5     ; opcode for `LDA $zp`
.DEF    CPU_LDA_ZPX     $b5     ; opcode for `LDA $zp, x`
.DEF    CPU_LDA_ABS     $ad     ; opcode for `LDA $nnnn`
.DEF    CPU_LDY         $a0     ; opcode for `LDY # $nn`
.DEF    CPU_JSR         $20     ; opcode for `JSR $nnnn`
.DEF    CPU_RTS         $60     ; opcode for `RTS`
.DEF    CPU_BRK         $00     ; opcode for `BRK`

; macro to polyfill 65C02's PusH-X instruction
;-------------------------------------------------------------------------------
.MACRO  .phx                                                            ;cycles
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        .IFDEF  CPU_65C02
                phx             ; native to the 65C02                   ;+3
        .ELSE
                txa             ; pass via A register                   ;+2
                pha                                                     ;+3
        .ENDIF
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; macro to polyfill 65C02's PusH-Y instruction
;-------------------------------------------------------------------------------
.MACRO  .phy                                                            ;cycles
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        .IFDEF  CPU_65C02
                phy             ; native to the 65C02                   ;+3
        .ELSE
                tya             ; pass via A register                   ;+2
                pha                                                     ;+3
        .ENDIF
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; macro to polyfill 65C02's PuLl-X instruction
;-------------------------------------------------------------------------------
.MACRO  .plx                                                            ;cycles
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        .IFDEF  CPU_65C02
                plx             ; native to the 65C02                   ;+3
        .ELSE
                pla             ; pass via A register                   ;+2
                tax                                                     ;+3
        .ENDIF
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; macro to polyfill 65C02's PuLl-Y instruction
;-------------------------------------------------------------------------------
.MACRO  .ply                                                            ;cycles
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        .IFDEF  CPU_65C02
                ply             ; native to the 65C02                   ;+3
        .ELSE
                pla             ; pass via A register                   ;+2
                tay                                                     ;+3
        .ENDIF
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; macro to polyfill 65C02's STore-Zero instruction
;-------------------------------------------------------------------------------
.MACRO  .stz                                                            ;cycles
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        .IFDEF  CPU_65C02
                stz \1          ; native to the 65C02                   ;+3|4
        .ELSE
                lda # 0         ; load a zero first,                    ;+2
                sta \1          ; and store                             ;+3|4
        .ENDIF
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; an optimisation, to avoid extra branching, is to jump into the middle of an
; instruction which is then interpretted as some other instruction. a common
; example of this is using the `bit` instruction as a 'do nothing' instruction
; with the option to jump over the `bit` opcode and treat the 2-byte parameter
; as a different instruction:
;
;     bit $00a9 ;<-- this is `lda # $00` if you skip the `bit` opcode
;
; this macro simply outputs the opcode for the `bit` instruction,
; causing the next 2-byte instruction to be 'ignored'. for example:
;
;    do_one_thing:
;         lda # $ff
;        .bit_skip2     ; skip the next `lda` by making it a `bit` instruction
;
;     do_a_different_thing:
;         lda # $00
;
;-------------------------------------------------------------------------------
.MACRO  .bit_skip2
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        .BYTE   $2c
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; this is a version that skips one byte
;-------------------------------------------------------------------------------
.MACRO  .bit_skip1
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        .BYTE   $24
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM
