; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; stack.pla : shared stack routines
;===============================================================================

; lower the stack
;-------------------------------------------------------------------------------
; this lowers the stack, checking for overflow, but does not change any data.
; the direction the stack moves is implementation specific and never exposed
; to Pling scripts
;
.MACRO  .lowerStack
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        dex
        bpl @lowerStack__\@
        jmp err_stack_overflow

@lowerStack__\@:
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; lower the stack twice, using one error check for efficiency
;
.MACRO  .lowerStack2
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        dex
        dex
        bpl @lowerStack2__\@
        jmp err_stack_overflow

@lowerStack2__\@:
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; raise the stack
;-------------------------------------------------------------------------------
; this raises the stack, checking for underflow, but does not change any data.
; the direction the stack moves is implementation specific and never exposed
; to Pling scripts
;
.MACRO  .raiseStack
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        inx
        cpx # PL_STACK_SIZE+1
        bcc @raiseStack__\@
        jmp err_stack_underflow

@raiseStack__\@:
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; raise the stack twice, using one error check for efficiency
;
.MACRO  .raiseStack2
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        inx
        inx
        cpx # PL_STACK_SIZE+1
        bcc @raiseStack2__\@
        jmp err_stack_underflow

@raiseStack2__\@:
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

push_byte:
        ;=======================================================================
        ; push a byte onto the data stack,
        ; setting the data-type too
        ;
        ;   A = value
        ;
        ;-----------------------------------------------------------------------
        .lowerStack
        ; set the byte value:
        sta zp_stack, x
        ; set the data-type:
.IFDEF  CPU_65C02
        ; this 65C02 optimisation relies upon `TYPE_BYTE` being zero...
        ; sanity check this in case of unintended change in the future
        .IF TYPE_BYTE != 0
                .PRINT "TYPE_BYTE is not 0!"
                .FAIL
        .ENDIF
        stz zp_type, x
.ELSE   ;6502
        lda # TYPE_BYTE
        sta zp_type, x
.ENDIF
        rts

push_word:
        ;=======================================================================
        ; push a word onto the data stack,
        ; setting the data type too
        ;
        ;   A = value, lo-byte
        ;   Y = value, hi-byte
        ;
        ;-----------------------------------------------------------------------
        ; push the stack pointer down twice first
        .lowerStack2
        ; write the lo-byte first at the new top-most position
        sta zp_stack+0, x
        lda # TYPE_WORD_LO
        sta zp_type+0, x
        ; write the hi-byte underneath that
.IFDEF  CPU_65C02
        sty zp_stack+1, x
.ELSE   ;6502:
        tya
        sta zp_stack+1, x
.ENDIF
        lda # TYPE_WORD_HI
        sta zp_type+1, x

        rts

pop_byte:
        ;=======================================================================
        lda zp_type, x          ; check the data-type of the top stack item
        bne +                   ; if not a byte, error!

        lda zp_stack, x
        .raiseStack
        rts

        ; not a byte!
+       jmp err_type

pop_word:
        ;=======================================================================
        lda zp_type, x
        bpl +

        .raiseStack2
.IFDEF  CPU_65C02
        lda zp_stack-2, x
        ldy zp_stack-1, x
.ELSE   ;6502
        lda zp_stack-1, x       ; read the hi-byte first,
        tay                     ; to put it into Y
        lda zp_stack-2, x       ; and then A for the lo-byte
.ENDIF  
        rts

        ; not a word!
+       jmp err_type

;;pop:    ;=====================================================================
;;        ; pop a value off of the top of the stack
;;        ; returns:
;;        ; 
;;        ;       A = word lo-byte, or single byte
;;        ;       Y = word hi-byte (if data is a word)
;;        ;       c = 0 for a byte, 1 for a word 
;;        ;
;;        ;---------------------------------------------------------------------
;;        ; is the top-most item a byte or a word?
;;        lda zp_type, x          ; get the data type
;;        ;;cmp # 0                 ; return c=1 for word, and c=0 for byte!
;;        bmi +
;;
;;        ; read a byte:
;;        ;---------------------------------------------------------------------
;;        .raiseStack
;;        lda zp_stack-1, x
;;        rts
;;
;;        ; read a word:
;;        ;---------------------------------------------------------------------
;;+       .raiseStack2
;;.IFDEF  CPU_65C02
;;        lda zp_stack-2, x
;;        ldy zp_stack-1, x
;;.ELSE   ;6502
;;        lda zp_stack-1, x       ; read the hi-byte first,
;;        tay                     ; to put it into Y
;;        lda zp_stack-2, x       ; and then A for the lo-byte
;;.ENDIF  
;;        rts