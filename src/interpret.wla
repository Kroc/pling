; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; interpret.wla
;===============================================================================

; interpret ( w -- )
;===============================================================================
; read source code input and execute
;
; in:   word    address of null-terminated ASCII text to interpret
;
; TODO: for now this merely reads a string already in memory, but with the
;       introduction of stream I/O we'll want this to be able to read from
;       any source
;
;-------------------------------------------------------------------------------
        _term   "interpret"

interpret:
        ;-----------------------------------------------------------------------
        ; jump straight to the routine for reading a single term,
        ; the same parameters apply
        jsr term_read_term

        brk
        
        rts

; read-term ( w -- w )
;===============================================================================
; read a term name from input
;
; in:   word    address of null-terminated ASCII text to read
;
;               since a term-name is limited to 31 characters, the string
;               will be indexed with 8-bits, placing an arbitrary limitation
;               that there cannot be more than 256-31 characters of delimiters
;               before the term-name begins
;
; out:  word    address of the new position of the input buffer,
;               the address having been moved forward over the new term
;
;-------------------------------------------------------------------------------
        _term   "read-term"

term_read_term:
        ;-----------------------------------------------------------------------
        ; since the top of the stack is a word, and we're going to return
        ; a word, we're going to just overwrite it instead of popping/pushing.
        ; we do need to move the value to the zero-page, though, for 6502
        ; indexed addressing
        ;
        lda zp_stack+0, x
        sta zp_addr+lo
        lda zp_stack+1, x
        sta zp_addr+hi

        ; skip initial delimiters:
        ;-----------------------------------------------------------------------
        ldy # 0
-       lda [zp_addr], y        ; read character from the buffer
        beq @eol                ; end-of-line, null-terminator?
        iny                     ; pre-emptively move to the next character
        cmp zp_delimiter        ; was it a delimiter?
        beq -                   ; yes, keep reading

        ; start reading characters:
        ;-----------------------------------------------------------------------
        ; backup Pling's stack pointer
        _phx
        ; the first byte of the term-name buffer is the string length.
        ; X will be used as the index into the term-name buffer
        ldx # 0
        stx zp_term_name
        ; begins at 1 because the 0th byte is the string-length
        inx

-       lda [zp_addr], y        ; read a character
        beq @done               ; null terminator?
        iny                     ; pre-emptively move to the next character
        cmp zp_delimiter        ; was it a delimiter?
        beq @done               ; if so, end term
      
        ; add the character to the term-name buffer
        sta zp_term_name, x     ; write character to the term buffer
        inc zp_term_name        ; increment its length
        inx                     ; move to the next available space

        ; go read next character        
        bne -

        ;-----------------------------------------------------------------------
        ; the term name has been read:
        ;
        ; restore Pling's stack pointer
@done:  _plx

        ; move the input buffer's address forward
        ; by the number of characters we read
        ;
        tya                     ; number of characters read (inc. delimiters)
        clc                     ; (it's math time!)
        adc zp_addr+lo          ; add to the original address
        sta zp_stack+0, x       ; return the lo-byte
        lda zp_addr+hi          ; ripple the carry...
        adc # 0                 ; to the address hi-byte
        sta zp_stack+1, x       ; return the hi-byte

        rts

        ; end-of-line:
        ;-----------------------------------------------------------------------
@eol:   ; put $0000 on the stack to indicate no term found:
        ;
.IFDEF  CPU_65C02
        ; (this is not actually faster, just clearer intent)
        stz zp_stack+0, x
        stz zp_stack+1, x
.ELSE   ;6502
        ; (the null-terminator was already zero,
        ;  so we don't have to load a zero)
        sta zp_stack+0, x
        sta zp_stack+1, x
.ENDIF
        rts

; find-term ( -- w )
;===============================================================================
; searches the terminology for a term matching the name currently
; in the term-name buffer (use `read-term` to populate this)
;
; out:  word    execution address of the found term
;
;-------------------------------------------------------------------------------
        _term   "find-term"

term_find_term:
        ;-----------------------------------------------------------------------
        ; start searching from the last defined word. this address points
        ; to the term header, *not* the term's code
        ;
        ; the first two bytes of a term header are the address of the previous
        ; term, allowing one to follow the chain back through terms
        ;
        lda zp_last+lo
        sta zp_addr+lo
        lda zp_last+hi
        sta zp_addr+hi

        ldy # 2
        jmp @len

        ; (this is a post-loop fall-through)
        ;-----------------------------------------------------------------------
        ; not same length! move to the next term in the chain:
        ; read the back-link address from the term-header
@next:  ldy # 0
        lda [zp_addr], y
        sta zp_addr+lo
        iny                     ; Y=1
        lda [zp_addr], y
        beq @none
        sta zp_addr+hi
        iny                     ; Y=2

        ; after this, follows the term's name, the first byte is the length.
        ; read the length from the header: (third byte)
@len:   lda [zp_addr], y
        ; TODO: error if length of term-name is 0

        ; a speed optimisation common with Forths is to simply
        ; compare string lengths first... (the first byte of
        ; the term-name buffer is its length)
        cmp zp_term_name
        ; if not the same length, move to the next term
        bne @next

        ; compare strings:
        ;-----------------------------------------------------------------------
        ; walk along the bytes of the two strings and compare each letter:
-       iny
        lda zp_term_name-3, y   ; (the offsets differ, so compensate)
        beq +                   ; end of the string, word matches!
        cmp [zp_addr], y        ; (this is so cool you can do this)   
        beq -                   ; letters, match, keep searching

        ; names do not match -- move to the next term in the chain
        bne @next

        ; term found!
        ;-----------------------------------------------------------------------
        ; push the found term's execution address
+       lda zp_addr+lo
        ldy zp_addr+hi
        jmp push_word

        ; term not found!
        ;-----------------------------------------------------------------------
@none:  brk
        brk

;;; new-term ( -- )
;;;=============================================================================
;;; create a new term; the name of the term is read from the input buffer
;;;
;;;-----------------------------------------------------------------------------
;;        _term   "new-term"
;;
;;new_term:
;;        ;---------------------------------------------------------------------
;;        ; read the name of the next term:
;;        ;
;;        lda # $20               ; space = delimiter
;;        dex
;;        sta zp_stack, x
;;        jsr term
;;
;;        ; this is now the last defined term:
;;        lda pl_here_lo
;;        sta pl_last_lo
;;        lda pl_here_hi
;;        sta pl_last_hi
;;
;;        ; the new term begins with the address
;;        ; of the previous one: (back-link)
;;        ;
;;.IFNDEF CPU_65C02
;;        ldy # 0
;;.ENDIF
;;        lda pl_last_lo          ; load address lo-byte of last term
;;.IFDEF  CPU_65C02
;;        sta [pl_here]           ; save at the new term's address
;;.ELSE
;;        sta [pl_here], y
;;.ENDIF
;;        inc pl_here_lo          ; move to the next byte of memory
;;        bcc +                   ; page crossed?
;;        inc pl_here_hi          ; (move to next page)
;;+       lda pl_last_hi          ; load address hi-byte of last term
;;.IFDEF  CPU_65C02
;;        sta [pl_here]           ; save at the new term's address
;;.ELSE
;;        sta [pl_here], y
;;.ENDIF
;;        inc pl_here_lo          ; move to the next byte of memory
;;        bcc +                   ; page crossed?
;;        inc pl_here_hi          ; (move to next page)
;;
;;        ; write the name of the term to its terminology entry;
;;        ; this includes the first byte which is the length of the term name
;;        ;
;;        ldy # 0
;;-       lda pl_buffer_term, y   ; read a character
;;        sta [pl_here]           ; write a character
;;        inc pl_here_lo          ; move to the next writing address
;;        bcc +                   ; page crossed?
;;        inc pl_here_hi          ; (move to next page)
;;+       iny
;;        cpy pl_buffer_term
;;        bne -
;;
;;        rts
