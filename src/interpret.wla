; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; interpret.wla : string & number parsing
;===============================================================================
; label:                    stack:              term-name:
;-------------------------------------------------------------------------------
; term_line_input:            --                "line-input"
; term_interpret:           w --                "interpret"
; term_read_term:           w -- w              "read-term"
; term_find_term:             -- w | EOD        "find-term"
; term_parse_number:          -- b | w          "parse-number"
;

; line-input ( -- )
;===============================================================================
; wait for the user to type a line of text:
; the input is stored on the system's input line-buffer ($0200)
;
; TODO: this to be redone completely. the C64's KERNAL routine allows
;       pressing the cursor keys during input
;-------------------------------------------------------------------------------
        .term   "line-input"

term_line_input:
        ;-----------------------------------------------------------------------
        ldy # 0

-       jsr KERNAL_CHRIN        ; read a character from the keyboard
        cmp # $d                ; is the key RETURN?
        beq +                   ; if yes, quit reading
        
        sta $0200, y            ; add the key-code to the buffer
        iny                     ; move to the next character
        cpy # 81                ; have we hit the end of the line?
        bne -

+       jsr sys_emit            ; actually print the RETURN (go to next line)
        
        ; append a null-terminator
.IFDEF  CPU_65C02
        stz $0200, y
.ELSE   ;6502
        lda # 0
        sta $0200, y
.ENDIF
        lda #< $0200
        ldy #> $0200
        jsr push_word
        jmp term_interpret


; interpret ( w -- )
;===============================================================================
; read source code input and execute
;
; in:   word    address of null-terminated ASCII text to interpret
;
; TODO: for now this merely reads a string already in memory, but with the
;       introduction of stream I/O we'll want this to be able to read from
;       any source
;
;-------------------------------------------------------------------------------
        .term   "interpret"

term_interpret:
        ;-----------------------------------------------------------------------
        ; jump straight to the routine for reading a term from input,
        ; the same parameters apply
        jsr term_read_term
        ; TODO: error handling
        ; find the term in the terminology
        jsr term_find_term
        ; TODO: if not found, parse as a number

        ; TODO: error handling
        ; execute it!
        ;;jsr term_exec

-       inc VIC_BORDER
        jmp -
        kil
        
        rts

; read-term ( w -- w )
;===============================================================================
; read a term name from input
;
; in:   word    address of null-terminated ASCII text to read
;
;               since a term-name is limited to 31 characters, the string
;               will be indexed with 8-bits, placing an arbitrary limitation
;               that there cannot be more than 256-31 characters of delimiters
;               before the term-name begins
;
; out:  word    address of the new position of the input buffer,
;               the address having been moved forward over the new term
;
;-------------------------------------------------------------------------------
        .term   "read-term"

term_read_term:
        ;-----------------------------------------------------------------------
        ; since the top of the stack is a word, and we're going to return
        ; a word, we're going to just overwrite it instead of popping/pushing.
        ; we do need to move the value to the zero-page, though, for 6502
        ; indexed addressing
        ;
        ; this routine will check stack underflow & data-type
        jsr peek_word
        sta zp_addr+LO
        sty zp_addr+HI

        ; skip initial delimiters:
        ;-----------------------------------------------------------------------
        ; note that we must leave the index on a non-delimiter character,
        ; rather than the next [unread] character. this requires incrementing
        ; the index before testing, instead of after, which is why we begin
        ; with an index of -1 before entering the loop
        ;
        ldy # -1
-       iny                     ; pre-emptively move to the next character
        lda [zp_addr], y        ; read character from the input string
        beq @eol                ; end-of-line, null-terminator?
        cmp zp_delimiter        ; was it a delimiter?
        beq -                   ; yes, keep reading

        ; start reading characters:
        ;-----------------------------------------------------------------------
        ; backup Pling's stack pointer
        .phx
        ; the first byte of the term-name buffer is the string length.
        ; X will be used as the index into the term-name buffer
        ldx # 0
        stx zp_term_name
        ; writing characters begins at 1 because
        ; the 0th byte is the string-length
        inx

-       lda [zp_addr], y        ; read a character
        beq @done               ; null terminator?
        iny                     ; pre-emptively move to the next character
        cmp zp_delimiter        ; was it a delimiter?
        beq @done               ; if so, end term
      
        ; add the character to the term-name buffer
        sta zp_term_name, x     ; write character to the term buffer
        inc zp_term_name        ; increment its length
        inx                     ; move to the next available space

        ; go read next character        
        bne -
        kil

        ;-----------------------------------------------------------------------
        ; the term name has been read:
@done:  ; the captured term name must be null-terminated
        ;
.IFDEF  CPU_65C02
        stz zp_term_name, x
.ELSE   ;6502
        lda # 0
        sta zp_term_name, x
.ENDIF
        ; restore Pling's stack pointer
        .plx

        ; move the input buffer's address forward
        ; by the number of characters we read
        ;
        tya                     ; number of characters read (inc. delimiters)
        clc                     ; (it's math time!)
        adc zp_addr+LO          ; add to the original address
        sta zp_stack+0, x       ; return the lo-byte
        lda zp_addr+HI          ; ripple the carry...
        adc # 0                 ; to the address hi-byte
        sta zp_stack+1, x       ; return the hi-byte

        rts

        ; end-of-line:
        ;-----------------------------------------------------------------------
@eol:   ; put $0000 on the stack to indicate no term found:
        ;
.IFDEF  CPU_65C02
        ; (this is not actually faster, just clearer intent)
        stz zp_stack+0, x
        stz zp_stack+1, x
.ELSE   ;6502
        ; (the null-terminator was already zero,
        ;  so we don't have to load a zero)
        sta zp_stack+0, x
        sta zp_stack+1, x
.ENDIF
        rts

; find-term ( -- w | EOD )
;===============================================================================
; searches the terminology for a term matching the name currently
; in the term-name buffer (use `read-term` to populate this)
;
; out:  word    execution address of the found term
;  or/  EOD     if the term name is not found, an End Of Data token
;
; TODO: return an End Of Data token instead of $0000;
;       will rely on error-type checking / testing
;-------------------------------------------------------------------------------
        .term   "find-term"

term_find_term:
        ;-----------------------------------------------------------------------
        ; start searching from the last defined word. this address
        ; points to the term header, *not* the term's code
        ;
        ; the first two bytes of a term header are the address of the previous
        ; term, allowing one to follow the chain back through terms
        ;
        lda zp_last+LO
        sta zp_addr+LO
        lda zp_last+HI
        sta zp_addr+HI

        ; after this, follows the term's name, the first byte is the length.
        ; read the length from the header: (third byte)
        ldy # 2
        jmp @len

        ; (this is a post-loop fall-through)
        ;-----------------------------------------------------------------------
        ; not same length! move to the next term in the chain:
        ; read the back-link address from the term-header
@next:  ldy # 0
        lda [zp_addr], y
        sta zp_addr+LO
        iny                     ; Y=1
        lda [zp_addr], y
        sta zp_addr+HI
        ; if back-link address is $0000, then we've reached the end
        ; of the chain -- the term has not been found
        beq @done
        iny                     ; Y=2

@len:   lda [zp_addr], y
        ; TODO: error if length of term-name is 0

        ; a speed optimisation common with Forths is to simply
        ; compare string lengths first... (the first byte of
        ; the term-name buffer is its length)
        cmp zp_term_name
        ; if not the same length, move to the next term
        bne @next

        ; compare strings:
        ;-----------------------------------------------------------------------
        ; walk along the bytes of the two strings and compare each letter:
-       iny
        lda zp_term_name-3, y   ; (the offsets differ, so compensate)
        beq @done               ; end of the string, word matches!
        cmp [zp_addr], y        ; (this is so cool you can do this)   
        beq -                   ; letters, match, keep searching

        ; names do not match -- move to the next term in the chain
        bne @next

        ;-----------------------------------------------------------------------
        ; if the term was not found, the address will be $0000; we only need
        ; to test the hi-byte as terms cannot exist within the first 256 bytes
        ; of RAM
        ;
@done   cpy #> $0000
        beq +

        lda zp_addr+LO
        ldy zp_addr+HI
        jmp push_word

        ;-----------------------------------------------------------------------
        ; instead of pushing $0000, we push an End Of Data token to avoid
        ; users accidentally trying to execute address $0000! attempting
        ; to read the token as a byte or word will give a data-type error
        ;
+       lda # 0                 ; the token's value is not important
        ldy # TOKEN_EOD         ; make it a token, not a regular byte
        jmp push_token

; parse-number ( -- b | w )
;===============================================================================
; parses the term-name buffer for a number.
; numbers can be in the format:
;
;        128    : decimal integers. <256 = byte, >255 = word
;         -1    : (negatives allowed)
;       0128    : zero-prefix forces word-size for decimals
;        -01    : (also for negatives)
;        $FF    : hexadecimal, 2 digits = byte
;      $0000    : 4 digits = word, even if value is <256
;  %01010101    : binary. 8 digits = byte, 16 digits = word
;
; TODO: ASCII character parsing, e.g. " 'a' "
; TODO: implement negative numbers
; TODO: allow negative hexadecimal / binary?
;
; this routine was roughly adapted from DurexForth's number parser:
; https://github.com/jkotlinski/durexforth/blob/master/interpreter.asm
;-------------------------------------------------------------------------------
        .term   "parse-number"

term_parse_number:
        ;-----------------------------------------------------------------------
        ldy zp_term_name        ; how many characters?
        beq @err                ; sanity check should NOT be zero!
        dey                     ; 1-character only?
        beq @single             ; optimisation for single character

        ; make room on top of the stack for our working number
        jsr term_00

        ; check the first character for hex `$` or `%` sigil
        lda zp_term_name+1
        cmp # '$'
        beq @hex
        cmp # '%'
        beq @bin

        ; parse decimal string
        ;-----------------------------------------------------------------------
        lda # 10                ; set base 10
        sta zp_int_base
        bne @loop
        kil

        ; optimisation for a single character:
        ;-----------------------------------------------------------------------
        ; a single character can only be a valid number if it's 0-9
        ;
@single lda zp_term_name+1
        sec
        sbc # '0'               ; ASCI "0" or above?
        cmp # 10                ; no higher than 9?
        bcs +

        ; A is now the number
        jmp push_byte

        ; ASCII code is not a number!
+       jmp err_parse

        ;-----------------------------------------------------------------------
@hex:   lda # 16
        sta zp_int_base
        iny
        bne @loop

@bin:   lda # 2
        sta zp_int_base
        iny
        bne @loop

        ;=======================================================================
        ; one digit converted! add to our running total:
        ; carry is already clear thanks to the base compare :)
@next:  adc zp_stack+0, x
        bcc +
        inc zp_stack+1, x
        ; are there more digits to process?
+       iny                     ; move to next character
        cpy zp_term_name        ; reached length of term?
        bcs @done

        .phy

        ; multiply working number by the base
        ; to effectively move up the digits
        lda zp_int_base
        jsr push_byte
        jsr term_multiply

        .ply
        ;-----------------------------------------------------------------------
        ; get an ASCII character
@loop:  lda zp_term_name+2, y

        ; convert to upper-case: note that Pling operates with ASCII
        ; internally; in ASCII, the capital letters follow the numerals,
        ; not the lower-case letters as is with PETSCII!
        ; TODO: do this only for hexadecimal?
        jsr term_asc2upper

        ; check for ASCII "0"-"9"
        sec
        sbc # '0'       ; ASCI "0" or above?
        cmp # 10        ; no higher than 9?
        bcc +
        ; there are 7 ASCII characters between "9" & "A", so if we subtract 7
        ; then "A" becomes 10, "B" = 11, ... "F" = 15 (since we've already
        ; established logically that the ASCII code is > "9")
        sbc # 7
        
        ; digit is 0-9 and "A" (10), or above, including > "F".
        ; check if the value is within the base range; if the base is 16
        ; then ASCII codes that were > "F" will not pass
        ;
+       cmp zp_int_base         ; is this within the intended base?
        bcc @next               ; if so, process the next digit

        ; fall through if base was incorrect for the size of the digit
@err:   jmp err_parse

        ;-----------------------------------------------------------------------
@done:  rts

;;; new-term ( -- )
;;;=============================================================================
;;; create a new term; the name of the term is read from the input buffer
;;;
;;;-----------------------------------------------------------------------------
;;        .term   "new-term"
;;
;;new_term:
;;        ;---------------------------------------------------------------------
;;        ; read the name of the next term:
;;        ;
;;        lda # $20               ; space = delimiter
;;        dex
;;        sta zp_stack, x
;;        jsr term
;;
;;        ; this is now the last defined term:
;;        lda pl_here_lo
;;        sta pl_last_lo
;;        lda pl_here_hi
;;        sta pl_last_hi
;;
;;        ; the new term begins with the address
;;        ; of the previous one: (back-link)
;;        ;
;;.IFNDEF CPU_65C02
;;        ldy # 0
;;.ENDIF
;;        lda pl_last_lo          ; load address lo-byte of last term
;;.IFDEF  CPU_65C02
;;        sta [pl_here]           ; save at the new term's address
;;.ELSE
;;        sta [pl_here], y
;;.ENDIF
;;        inc pl_here_lo          ; move to the next byte of memory
;;        bcc +                   ; page crossed?
;;        inc pl_here_hi          ; (move to next page)
;;+       lda pl_last_hi          ; load address hi-byte of last term
;;.IFDEF  CPU_65C02
;;        sta [pl_here]           ; save at the new term's address
;;.ELSE
;;        sta [pl_here], y
;;.ENDIF
;;        inc pl_here_lo          ; move to the next byte of memory
;;        bcc +                   ; page crossed?
;;        inc pl_here_hi          ; (move to next page)
;;
;;        ; write the name of the term to its terminology entry;
;;        ; this includes the first byte which is the length of the term name
;;        ;
;;        ldy # 0
;;-       lda pl_buffer_term, y   ; read a character
;;        sta [pl_here]           ; write a character
;;        inc pl_here_lo          ; move to the next writing address
;;        bcc +                   ; page crossed?
;;        inc pl_here_hi          ; (move to next page)
;;+       iny
;;        cpy pl_buffer_term
;;        bne -
;;
;;        rts
