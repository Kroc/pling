; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; term_interpret.wla : code & number parsing
;===============================================================================
; label:                    stack:              term-name:
;-------------------------------------------------------------------------------
; term_line_input:            --                "line-input"
; term_interpret:             -- * ERR?         "interpret"
; term_read_term:             -- EOD?           "read-term"
; term_find_term:             -- w | EOD        "find-term"
; term_exec:                w --                "exec"
; term_parse_number:          -- i              "parse-number"
; term_define:                --                ":"
; term_define_end:            --                ";"
;

; line-input ( -- )
;===============================================================================
; wait for the user to type a line of text:
; the input is stored on the system's input line-buffer
;
;-------------------------------------------------------------------------------
        .term   "line-input"

term_line_input:
        ;-----------------------------------------------------------------------
        ; let the user input a line of code,
        ; and don't return until they press return!
        ;
        jmp sys_input


; interpret ( -- * ERR? )
;===============================================================================
; read source code input and execute
;
; out:  *       execution of the intepretted code may push any quantity
;               of data of any type (including none at all) on the stack
;
;       ERR?    if an error occurs either in parsing or execution,
;               the error token is returned atop the stack
;
; TODO: for now this merely reads a string already in memory, but with the
;       introduction of channel I/O we'll want this to be able to read from
;       any source
;
;-------------------------------------------------------------------------------
        .term   "interpret"

term_interpret:
        ;-----------------------------------------------------------------------
-       jsr term_read_term      ; check the input buffer
        jsr pop_token_EOD       ; did we reach the end of the buffer?
        beq @rts                ; if yes, all work is done

        jsr term_find_term      ; search for the term in the terminology
        jsr pop_token_EOD       ; did we find the term?
        beq +                   ; not found; could it be a number?

        jsr term_exec           ; execute it!
        jmp -                   ; check for any further terms

        ; TODO: handle parse-number error
+       jsr term_parse_number   ; attempt to parse as a number
        jmp -                   ; check for any further terms

@rts:   rts


; read-term ( -- EOD? )
;===============================================================================
; read a term name from the input buffer
;
; NOTE: since a term-name is limited to 31 characters, the string will be
;       indexed with 8-bits, placing an arbitrary limitation that there
;       cannot be more than 256-31 characters of delimiters before the
;       term-name begins
;
; out:  EOD?    if the input string reaches the end without reading a term,
;               an End Of Data token is returned
;
; TODO: enforce 31-char limit
;-------------------------------------------------------------------------------
        .term   "read-term"

term_read_term:
        ;-----------------------------------------------------------------------
        ; skip initial delimiters:
        ;-----------------------------------------------------------------------
        ; note that we must leave the index on a non-delimiter character,
        ; rather than the next [unread] character. this requires incrementing
        ; the index before testing, instead of after, which is why we begin
        ; with an index of -1 before entering the loop
        ;
        ldy # -1
-       iny                     ; pre-emptively move to the next character
        lda [zp_input], y       ; read character from the input buffer
        beq @eod                ; null-terminator?
        cmp pl_delimiter        ; was it a delimiter?
        beq -                   ; yes, keep reading

        ; if we use Y to move forward the pointer in the input buffer, then the
        ; index for both the input buffer and the term-name (output) buffer can
        ; be the same, and we can use Y for both, forgoing the need to use
        ; another index register
        ;
        tya                     ; now represents the start of the term-name
        clc                     ; (it's math time!)
        adc zp_input+LO         ; add to the original address
        sta zp_input+LO         ; and write-back
        bcc +                   ; overflow?
        inc zp_input+HI         ; ripple the carry

        ; start reading characters:
        ;-----------------------------------------------------------------------
        ; TODO: limit to 31 characters!
        
        ; initialise the string-length we'll be using
        ; to track the length of the read term-name
+       ldy # 0
        sty pl_term_len

-       lda [zp_input], y       ; read a character
        beq @done               ; null terminator?
        cmp pl_delimiter        ; was it a delimiter?
        beq @done               ; if so, end term
      
        ; add the character to the term-name (output) buffer:
        ;
        sta pl_term_name, y     ; write character to the term-name buffer
        inc pl_term_len         ; increment its length

        ; go read next character
        iny                     ; move to the next character
        bne -                   ; always branches, assuming string len < 256
        kil

        ;-----------------------------------------------------------------------
        ; the term name has been read:
@done:  ; the captured term name must be null-terminated
        ;
.IFDEF  CPU_65C02
        stz pl_term_name, y
.ELSE   ;6502
        lda # 0
        sta pl_term_name, y
.ENDIF
        ; move the input buffer's address forward
        ; by the number of characters we read
        ;
        tya                     ; number of characters read
        clc                     ; (it's math time!)
        adc zp_input+LO         ; add to the base address
        sta zp_input+LO         ; write it back
        bcc +
        inc zp_input+HI         ; ripple the carry...
+       rts

        ; end-of-data:
        ;-----------------------------------------------------------------------
@eod:   ldy # TOKEN_EOD         ; return an End Of Data token
        jmp push_token


; find-term ( -- w | EOD )
;===============================================================================
; searches the terminology for a term matching the name currently
; in the term-name buffer (use `read-term` to populate this)
;
; out:  word    execution address of the found term
;  or/  EOD     if the term name is not found, an End Of Data token
;
;-------------------------------------------------------------------------------
        .term   "find-term"

term_find_term:
        ;-----------------------------------------------------------------------
        ; start searching from the last defined word. this address points
        ; to the term header, *not* the term's code (which follows)
        ;
        ; the first two bytes of a term header are the address of the previous
        ; term, allowing one to follow the chain back through terms
        ;
        lda zp_last+LO
        ldy zp_last+HI
        sta zp_addr+LO
        sty zp_addr+HI

        ; after this, follows the term's name, the first byte is the length.
        ; read the length from the header:
        ldy # 2                 ; third byte of term header
        bne @len                ; (always branches)

        ; (this is a post-loop fall-through)
        ;-----------------------------------------------------------------------
        ; not same length! move to the next term in the chain:
        ; read the back-link address from the term-header
        ;
@next:  ldy # 0                 ; back-link is the first word of the header,
        lda [zp_addr], y        ; read hi-byte
        
        ; if back-link address is $0000, then we've reached the end
        ; of the chain -- the term has not been found
        beq @eod

        pha                     ; (put lo-byte aside)
        iny                     ; Y=1
        lda [zp_addr], y        ; read hi-byte
        
        sta zp_addr+HI          ; change the pointer, hi-byte
        pla                     ; (retrieve lo-byte)
        sta zp_addr+LO          ; change the pointer, lo-byte

        iny                     ; Y=2

@len:   lda [zp_addr], y
        ; TODO: error if length of term-name is 0

        ; a speed optimisation common with Forths is to simply
        ; compare string lengths first... (the first byte of
        ; the term-name buffer is its length)
        cmp pl_term_len
        ; if not the same length, move to the next term
        bne @next

        ; compare strings:
        ;-----------------------------------------------------------------------
        ; walk along the bytes of the two strings and compare each letter:
-       iny
        lda pl_term_name-3, y   ; (offsets are different, so adjust)
        beq @done               ; end of the string, word matches!
        cmp [zp_addr], y        ; (this is so cool you can do this)   
        beq -                   ; letters, match, keep searching
        
        ; names do not match -- move to the next term in the chain
        bne @next

        ; return execution address:
        ;-----------------------------------------------------------------------
        ; the term has been found, but now we need to find the point where
        ; the machine code begins; this is after the header, and since the
        ; Y register should be positioned after the term's name string,
        ; we can use Y to move the address forward to the code
        ;
@done:  tya                     ; A = length of name
        ldy zp_addr+HI          ; Y will now be used as the hi-byte

        sec                     ; include +1, to step over the null-terminator 
        adc zp_addr+LO          ; add to the term's base address
        bcc +                   ; ripple?
        iny                     ; increase hi-byte

        ; A = address lo-byte,
        ; Y = address hi-byte; push to the stack
+       jmp push_word

        ; not found -- return EOD
        ;-----------------------------------------------------------------------
        ; instead of pushing $0000, we push an End Of Data token to avoid
        ; users accidentally trying to execute address $0000! attempting
        ; to read the token as a byte or word will give a data-type error
        ;
@eod:   lda # 0                 ; the token's value is not important
        ldy # TOKEN_EOD         ; make it a token, not a regular byte
        jmp push_token


; exec ( w -- )
;===============================================================================
; execute the address on top of the stack
;                                                                       ;cycles
;-------------------------------------------------------------------------------
        .term   "exec"

term_exec:                                                              ;=6
        ;-----------------------------------------------------------------------
        lda zp_type, x          ; check data-type                       ;+4=10
        bpl @err                ; *MUST* be a word!                     ;+2=12
        
        ; we must raise the stack by
        ; 2 bytes *before* we jump!
        inx                                                             ;+2=14
        inx                                                             ;+2=16

.IFDEF  CPU_65C02
        ; do a jump directly from the data stack, with -2
        ; to compensate for having already popped the stack
        jmp [zp_stack-2, x]                                             ;+6=22

.ELSE   ; 6502:
        ; if there's a faster way to do this, I'm all ears...
        lda zp_stack-2, x                                               ;+4=26
        sta zp_addr+LO                                                  ;+3=29
        lda zp_stack-1, x                                               ;+4=33
        sta zp_addr+HI                                                  ;+3=36
        jmp [zp_addr]                                                   ;+5=41
.ENDIF
        ;-----------------------------------------------------------------------
@err:   jmp err_type


; parse-number ( -- i )
;===============================================================================
; parses the term-name buffer for a number and pushes a byte or word
; (as appropriate) to the stack. numbers can be in the format:
;
;        128    : decimal integers. <256 = byte, >255 = word
;         -1    : (negatives allowed)
;       0128    : zero-prefix forces word-size for decimals
;        -01    : (also for negatives)
;        $FF    : hexadecimal, 2 digits = byte
;      $0000    : 4 digits = word, even if value is <256
;     -$FFFF    : (negatives allowed)
;  %01010101    : binary. 8 digits = byte, 16 digits = word
;
; TODO: ASCII character parsing, e.g. " 'a' "
; TODO: only single decimals are output as bytes so far
; TODO: data-type detection (byte/word by length)
;
; this routine was roughly adapted from DurexForth's number parser:
; https://github.com/jkotlinski/durexforth/blob/master/interpreter.asm
;-------------------------------------------------------------------------------
        .term   "parse-number"

term_parse_number:
        ;-----------------------------------------------------------------------
        ldy pl_term_len         ; how many characters?
        beq @err                ; sanity check: should NOT be zero!
        dey                     ; 1-character only?
        beq @single             ; optimisation for single character
        
        ; make room on top of the stack for our working number
        jsr term_00

        ldy # 0                 ; begin with the first character
        sty pl_digits           ; reset digit-count

        ; is the number negative?
        lda pl_term_name        ; check first character
        cmp # '-'               ; is it minus?
        bne +                   ; no, continue with +ve number
        iny                     ; skip over the minus sign
        
+       sty zp_sign             ; put aside the sign-bit for later

        ; check for `$` (hexadecimal) or `%` (binary) sigil:
        lda pl_term_name, y
        cmp # '$'
        beq @hex
        cmp # '%'
        beq @bin

        ; parse decimal string:
        ;-----------------------------------------------------------------------
@dec:   lda # 16
        sta zp_int_base
        bne @loop               ; (always branches)
        ;;jmp parse_decimal

        ;-----------------------------------------------------------------------
@hex:   lda # 16
        sta zp_int_base
        iny                     ; skip over the "$" sigil
        bne @loop               ; (always branches)

@bin:   lda # 2
        sta zp_int_base
        iny                     ; skip over the "%" sigil
        bne @loop               ; (always branches)

        ; optimisation for a single character:
        ;-----------------------------------------------------------------------
        ; a single character can only be a valid number if it's 0-9
        ;
@single lda pl_term_name        ; read the first character
        sec                     ; subtract:
        sbc # '0'               ; ASCI "0" or above?
        cmp # 10                ; no higher than 9?
        bcs @err

        ; A is now the number
        jmp push_byte

        ;=======================================================================
        ; one digit converted! add to our running total:
        ; carry is already clear thanks to the base compare :)
        ;
@next:  adc zp_stack+0, x       ; add the new decimal to current total
        sta zp_stack+0, x       ; write back result
        bcc +
        inc zp_stack+1, x       ; ripple the add

        ; are there more digits to process?
+       iny                     ; move to next character
        cpy pl_term_len         ; reached length of term?
        bcs @done

        ; multiply working number by the base
        ; to effectively move up the digits
        ; TODO: use specific optimisation for decimal:
        ;       <http://6502.org/source/integers/fastx10.htm>
        .phy
        lda zp_int_base
        jsr push_byte
        jsr term_multiply       ; NOTE: must preserve Y!
        .ply

        ;-----------------------------------------------------------------------
@loop:  lda pl_term_name, y     ; get an ASCII character
        beq @done               ; null terminator? finish up

        ; convert to upper-case:
        ;
        ; NOTE: Pling operates with ASCII internally; in ASCII, the capital
        ;       letters follow the numerals, not the lower-case letters as
        ;       is with PETSCII!
        ;
        ; TODO: do this only for hexadecimal?
        jsr asc2upper

        ; check for ASCII "0"-"9"
        sec
        sbc # '0'               ; ASCI "0" or above?
        cmp # 10                ; no higher than 9?
        bcc +

        ; there are 7 ASCII characters between "9" & "A", so if we subtract 7
        ; then "A" becomes 10, "B" = 11, ... "F" = 15 (since we've already
        ; established logically that the ASCII code is > "9")
        sbc # 7

        ; digit is 0-9 and "A" (10), or above, including > "F";
        ; check if the value is within the base range: if the base
        ; is 16 then ASCII codes that were > "F" will not pass
        ;
+       cmp zp_int_base         ; is this within the intended base?
        bcc @next               ; if so, process the next digit
        
        ; fall through if base was incorrect
        ; for the size of the digit
        ;
@err:   jmp err_parse           ; raise an error

        ;-----------------------------------------------------------------------
@done:  lda zp_sign             ; retrieve the negative-bit
        bne @neg                ; was it a negative number?
        rts
        ;-----------------------------------------------------------------------
@neg:   jmp term_neg            ; flip the number to make it negative


;;parse_decimal:
;;        ;=====================================================================
;;        ; are there more digits to process?
;;        ;
;;-       lda pl_term_name, y     ; get an ASCII character
;;        beq @done               ; null terminator? finish up
;;        pha                     ; put aside the ASCII digit momentarily
;;        iny                     ; move to next character
;;
;;        ; multiply result by 10
;;        ; <http://nparker.llx.com/a2/mult.html>
;;        ;---------------------------------------------------------------------
;;        lda zp_stack+0, x
;;        sta zp_temp+LO          ; start with RESULT = NUM
;;        lda zp_stack+1, x
;;        sta zp_temp+HI
;;
;;        asl zp_stack+0, x
;;        rol zp_stack+1, x       ; RESULT = 2*NUM
;;        asl zp_stack+0, x
;;        rol zp_stack+1, x       ; RESULT = 4*NUM
;;        clc
;;        lda zp_temp+LO
;;        adc zp_stack+0, x
;;        sta zp_stack+0, x
;;        lda zp_temp+HI
;;        adc zp_stack+1, x
;;        sta zp_stack+1, x       ; RESULT = 5*NUM
;;        
;;        asl zp_stack+0, x
;;        rol zp_stack+1, x       ; RESULT = 10*NUM
;;
;;        ; check for ASCII "0"-"9"
;;        pla                     ; retrieve ASCII digit
;;        sec                     ; subtract:
;;        sbc # '0'               ; ASCI "0" or above?
;;        cmp # 10                ; no higher than 9?
;;        bcs @err
;;
;;        ; add to the running total:
;;        adc zp_stack+0, x       ; add the new decimal to current total
;;        sta zp_stack+0, x       ; write back result
;;        bcc -
;;        inc zp_stack+1, x       ; ripple the add
;;        bne -
;;
;;        kil                     ; overflow?
;;
;;@done   lda zp_sign             ; retrieve the negative-bit
;;        bne @neg                ; was it a negative number?
;;        rts
;;        ;---------------------------------------------------------------------
;;@neg:   jmp term_neg            ; flip the number to make it negative
;;        ;---------------------------------------------------------------------
;;@err:   jmp err_parse           ; raise an error
;;
;;
;;parse_binary:
;;        ;=====================================================================
;;        ; skip over the "%" sigil
;;-       iny
;;        beq @done
;;
;;        kil
;;
;;@done   rts
;;@err:   jmp err_parse           ; raise an error


; : ( -- )
;===============================================================================
; the term that defines new terms:
;
; TODO: cannot define a term, when a term is already being defined
;-------------------------------------------------------------------------------
        .term   ":"

term_define:
        ;-----------------------------------------------------------------------
        ; TODO: error if we read ";"?
        ;
        jsr term_read_term      ; read the next term name
        jsr pop_token_EOD       ; check for End of Data
        beq @err

        ; create term header:
        ;-----------------------------------------------------------------------
        ; each term begins with a backlink
        ; -- the address of the previous term:
        
        ; push the address of the last term defined on the stack
        jsr term_last_term

        ; set the new term as the "latest" term
        ; (before we advance the user-space cursor)
        ; TODO: create `!term` to do this
        lda zp_here+LO
        sta zp_last+LO
        lda zp_here+HI
        sta zp_last+HI

        ; write the address of the last term to the new term header
        jsr term_write_here

        ; after the backlink, follows the term's name:
        ; the first byte is the string-length
        lda pl_term_len
        jsr asm
        
        ; copy the term-name buffer into the new term's header:
        ; TODO: cleaner solution for this -- a generic 'copy-string-to-here'?
        ldy # 0
-       lda pl_term_name, y
        beq +
        jsr asm
        iny
        bne -
        ; note that we must include the null-terminator in the term-header,
+       jsr asm

        ; compile term:
        ;-----------------------------------------------------------------------
        ; begin reading terms and compiling them into
        ; the new term, rather than executing them
        ;
@loop:  jsr term_read_term      ; read a term name from the input buffer
        jsr pop_token_EOD       ; any result?
        beq @done               ; should we error if EOD before ";"?
        jsr term_find_term      ; try find the name in the terminology
        jsr pop_token_EOD       ; did we find the term?
        bne @int

        ; assemble a JSR at `here`
        ;
        kil

        ;-----------------------------------------------------------------------
        ; TODO: enable quote/compile mode!
@done:  rts

        ;-----------------------------------------------------------------------
@int:   jsr term_parse_number   ; try parse the unknown term as a number
        
        ; the number having been parsed,
        ; assemble a `push_word` into user-space
        jsr term_push_here

        rts

        ;-----------------------------------------------------------------------
        ; a term name must follow `:`
        ; TODO: add a specific error message for this
@err:   jmp err_parse


; ; ( -- )
;===============================================================================
; the term that ends a current definition:
;
; TODO: error if term is not currently being defined
;-------------------------------------------------------------------------------
        .term   ";"

term_define_end:
        ;-----------------------------------------------------------------------
        ; TODO: end quote/compile mode!
        ;
        jmp asm_rts