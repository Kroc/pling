; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; terms_nucleus.wla
;===============================================================================
; these are the absolute bear minimum of words that *have* to be implemented
; in native assembly language in order to port the rest of Pling

; emit ( b -- )
;===============================================================================
; TODO: this implementation is temporary
;
;-------------------------------------------------------------------------------
        .term   "emit"

term_emit:
        ;-----------------------------------------------------------------------
        jsr pop_byte
        jmp KERNAL_CHROUT

; 0 ( -- b)
;===============================================================================
; pushes zero (as a byte) on to the stack:
; this is provided as an optimisation to avoid the number-parser
;
;-------------------------------------------------------------------------------
        .term "0"

term_0:
        ;-----------------------------------------------------------------------
        ; normally we would call `push_byte`, but since we know the value
        ; will be zero, and the byte data-type is zero as well, we can combine
        ; them. this optimisation relies upon `TYPE_BYTE` being zero, so we
        ; sanity check this in case of unintended change in the future
        ;
        .IF TYPE_BYTE != 0
                .PRINT "TYPE_BYTE is not 0!"
                .FAIL
        .ENDIF

        ; raise the stack to make room for the byte
        jsr .raiseStack

        ; write two zeroes:
.IFDEF  CPU_65C02
        stz zp_stack, x
        stz zp_type, x
.ELSE   ;6502
        lda # 0
        sta zp_stack, x
        sta zp_type, x
.ENDIF
        rts

; 00 ( -- w)
;===============================================================================
; pushes zero (as a word) on to the stack:
; this is provided as an optimisation to avoid the number-parser
;
;-------------------------------------------------------------------------------
        .term "00"

term_00:
        ;-----------------------------------------------------------------------
        lda # 0
        jmp push_word

; ! ( b w -- )
;===============================================================================
; pokes the byte atop the stack into the address below.
; all items are consumed
;
;-------------------------------------------------------------------------------
        .term   "!"

term_set:
        ;-----------------------------------------------------------------------
        lda zp_stack+2, x       ; get value to store (3rd byte)
        sta [zp_stack, x]       ; store via the address on the stack

        inx                     ; consume...
        inx                     ; three...
        inx                     ; bytes

        rts

; @ ( w -- b )
;===============================================================================
; peeks a byte from the address on the stack, (consuming the address)
; and pushes the value to the stack
;
;-------------------------------------------------------------------------------
        .term   "@"

term_get:
        ;-----------------------------------------------------------------------
        lda [zp_stack, x]
        inx
        sta zp_stack, x

        rts

; drop ( x -- )
;===============================================================================
; forget the top-most item on the stack, moving the stack down
; to the next item
;
;-------------------------------------------------------------------------------
        .term   "drop"

term_drop:
        ;-----------------------------------------------------------------------
        ; is the top-most item a byte or a word?
        lda zp_type, x
        beq +
        inx                     ; drop word
+       inx                     ; drop byte
        rts

; exec ( w -- )
;===============================================================================
; execute the address on top of the stack
;
;-------------------------------------------------------------------------------
        .term   "exec"

term_exec:
        ;-----------------------------------------------------------------------
        ; we must reduce the stack by 2 bytes *before* we jump!
        ; (must check for stack underflow before jumping)
        .raiseStack2

.IFDEF  CPU_65C02
        ; 65C02: do a jump directly from the data stack,
        ; with +2 to compensate for already having popped the stack
        jmp [zp_stack+2, x]

.ELSE   ; 6502:
        lda zp_stack+2, x
        sta zp_jmp+LO
        lda zp_stack+3, x
        sta zp_jmp+HI
        jmp [zp_jmp]
.ENDIF