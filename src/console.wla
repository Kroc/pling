; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; console.wla
;===============================================================================

.RAMSECTION "console"   SLOT 0  RETURNORG
        ; console cursor position
        zp_crsr_col     BYTE
        zp_crsr_row     BYTE
        ; current screen-RAM address of the cursor;
        ; this is where the next character will be written
        zp_crsr_addr    WORD
        ; text colour of the cursor
        ; (what colour is used when printing new characters)
        zp_crsr_colour  BYTE
.ENDS

; machine constants for the console:
;
.IFDEF  SYSTEM_C64
        ; the C64 cannot change screen resolution in text-mode,
        ; so the console is a fixed size. the console is one-line
        ; short of the screen-height to make room for a status bar

        .DEF    CON_COLS        SCREEN_COLS
        .DEF    CON_ROWS        SCREEN_ROWS-1

        ; a pair of lookup tables (lo/hi) to find the starting screen-RAM
        ; address for a given *screen* row. the console's rows might be
        ; offset from these
        ;
        screen_rows_lo:
        ;-----------------------------------------------------------------------
        .REPEAT SCREEN_ROWS INDEX R
                .BYTE   <(pl_screen + (R * 40))
        .ENDR
        screen_rows_hi:
        ;-----------------------------------------------------------------------
        .REPEAT SCREEN_ROWS INDEX R
                .BYTE   >(pl_screen + (R * 40))
        .ENDR
.ELSE
        .FAIL
.ENDIF

; TODO: calculate the cursor position from the screen-address --
;       we don't need to advance the variable for every character printed
;       as requests for cursor position will be much less common than printing

; ?con.cols ( -- b )
;===============================================================================
; gets the current number of console columns, minus 1 (i.e. zero-based).
; NOTE: the number of columns in the console may not be the same as the number
;       of columns on the screen! the console might have a scrollbar
; NOTE: some systems can change screen size (e.g. Commander X16),
;       so do not rely on the value being constant
;
;-------------------------------------------------------------------------------
        _prevTerm
        .BYTE   9, "?con.cols"
term_peek_con_cols:

        .IFDEF  SYSTEM_C64
                lda # CON_COLS
                jmp push_byte
        .ELSE
                .FAIL
        .ENDIF
        rts

; ?con.rows ( -- b )
;===============================================================================
; gets the current number of console rows, minus 1 (i.e. zero-based).
; NOTE: the number of rows in the console may not be the same as the number
;       of rows on the screen! the console may be using a status / input line.
; NOTE: some systems can change screen size (e.g. Commander X16),
;       so do not rely on the value being constant
;
;-------------------------------------------------------------------------------
        _prevTerm
        .BYTE   9, "?con.rows"
term_peek_con_rows:

        .IFDEF  SYSTEM_C64
                lda # CON_ROWS
                jmp push_byte
        .ELSE
                .FAIL
        .ENDIF
        rts

; ?con.back ( -- b )
;===============================================================================
; gets the console background colour. the return value is machine-dependent;
; Pling makes no effort to normalise colour across systems
;
;-------------------------------------------------------------------------------
        _prevTerm
        .BYTE   9, "?con.back"
term_peek_con_back:

        .IFDEF  SYSTEM_C64
                lda VIC_BACKGROUND
                inx
                sta zp_stack, x
                lda # TYPE_BYTE
                sta zp_type, x
        .ELSE
                .FAIL
        .ENDIF
        rts

; !con.back ( b -- )
;===============================================================================
; sets the console background colour. the value used is machine-dependent;
; Pling makes no effort to normalise colour across systems
;
;-------------------------------------------------------------------------------
        _prevTerm
        .BYTE   9, "!con.back"
term_poke_con_back:

        .IFDEF  SYSTEM_C64
                lda zp_stack, x
                sta VIC_BORDER
                sta VIC_BACKGROUND
                dex
        .ELSE
                .FAIL
        .ENDIF
        rts

; con.home ( -- )
;===============================================================================
; homes the cursor -- moves it back to row/col 0
;
;-------------------------------------------------------------------------------
        _prevTerm
        .BYTE   8, "con.home"
term_con_home:

        ; set the cursor write-address
        ; to the beginning of screen RAM
        lda #< pl_screen
        sta zp_crsr_addr+lo
        lda #> pl_screen
        sta zp_crsr_addr+hi

        lda # 0
        sta zp_crsr_col
        sta zp_crsr_row
        rts

; con.clear ( -- )
;===============================================================================
; clears the console
;
;-------------------------------------------------------------------------------
        _prevTerm
        .BYTE   9, "con.clear"
term_con_clear:

        ; swtich on I/O
        lda CPU_CONTROL
        pha
        lda # %00110111
        sta CPU_CONTROL

        ; clear with space char
        lda # $20

        ; write four 256-byte strips simultaneously
        ; so we don't have to deal with nested loops
        ldy # $00
-       sta $d800 + $000, y
        sta $d800 + $100, y
        sta $d800 + $200, y
        sta $d800 + $300, y
        dey
        bne -
        
-       sta pl_screen + $000, y
        sta pl_screen + $100, y
        sta pl_screen + $200, y
        sta pl_screen + $300, y
        dey
        bne -

        ; home the cursor
        jsr term_con_home

        pla
        sta CPU_CONTROL

        rts

; >con ( b -- )
;===============================================================================
; writes a raw byte to the console, advancing the cursor and scrolling,
; if necessary. DOES NOT DO ANY TEXT CONVERSION! the value of the byte
; is machine-dependent:
;
;       C64 : screen code, mapping to character ROM
;
;-------------------------------------------------------------------------------
        _prevTerm
        .BYTE   4, ">con"
term_write_con:

        ; get the byte from the stack
        ; TODO: error if data-type is word?
        jsr pop
        ; write to the current screen-RAM address
.IFDEF  CPU_65C02
        sta (zp_crsr_addr)
.ELSE
        ldy # 0
        sta (zp_crsr_addr), y
.ENDIF
        ; screen memory on the C64 is contiguous so we only need
        ; to check for going off the last console row. unfortunately
        ; the screen doesn't end on a page-boundary, so we have to
        ; check for *every* cursor advancement, and that's sad :(
        ;
        ; we're going to try combine the two behaviours of
        ; incrementing the cursor address and looking for
        ; for the last screen address
        ;
        ldy zp_crsr_addr+lo
        cpy #< (pl_screen + (CON_COLS * CON_ROWS)) - 1
        bne ++

        ; the lo-byte is that of the last-byte before the end of the console,
        ; but the hi-byte has not been checked yet! our current logic however
        ; means that we *know* what the next lo-address will be if we advance
        ; the cursor [should the hi-byte not match]
        ;
        tya                     ; put aside lo-address
        ldy zp_crsr_addr+hi     ; get hi-address

        cpy #> (pl_screen + (CON_COLS * CON_ROWS)) - 1
        ; if the hi-address doesn't match, then we advance the cursor as normal
        bne +       

        ; CONSOLE OVERFLOW:
        ; TODO: scroll the screen down
        jmp term_con_home

        ; restore the lo-address
+       tay

        ; increase the lo-address
++      iny
        sty zp_crsr_addr+lo
        bne +
        inc zp_crsr_addr+hi

+       rts