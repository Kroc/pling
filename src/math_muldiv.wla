; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; math_mudiv.wla : math multiply & divide routines
;===============================================================================
; multipling and dividing on 8-bit systems is a complicated process

; * ( i i -- w )
;===============================================================================
; multiply one data item by another:
;
; both items can be either bytes or words, any combination can be used.
; the output is always a word.
;
; TODO: in the case of word*word overflow, store this elsewhere
;       for optional recovery by another term
;
; in:   int     starting number, the "multiplicand"
;       int     the amount to multiply by, the "multiplier"
;
; out:  word    result, as a word
;
;-------------------------------------------------------------------------------
        .term   "*"

term_multiply:
        ;-----------------------------------------------------------------------
        ; pop the top item off the stack, be it a byte or word:
        ; this routine will return A = lo, Y = hi, where Y = 0 if the
        ; item was a byte (i.e. automatically forming a word)
        jsr pop_int
        ; this word is our multipler -- the amount we're multiplying by
        sta zp_temp+LO
        sty zp_temp+HI
        
        ; the top of the stack is now the multiplicand, the starting number
        ; to multiply, so we can just work directly off the stack
        jsr term_byte2word

        ; clear the overflow word
.IFDEF  CPU_65C02
        stz zp_overflow+LO
        stz zp_overflow+HI
.ELSE   ;6502
        lda # $00
        sta zp_overflow+LO
        sta zp_overflow+HI
.ENDIF
        ; set binary count to 16
        ldy # 16

        ; divide multiplier by 2
@lsr:   lsr zp_temp+HI
        ror zp_temp+LO
        bcc @ror
        lda zp_overflow+LO      ; get upper half of product and add multiplicand
        clc
        adc zp_stack+0, x       ; multiplicand
        sta zp_overflow+LO
        lda zp_overflow+HI
        adc zp_stack+1, x       ; multiplicand+1

@ror:   ror                     ; rotate partial product
        sta zp_overflow+HI
        ror zp_overflow+LO
        ror zp_stack+1, x
        ror zp_stack+0, x
        dey
        bne @lsr
        
        rts