; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; math.wla : core number & math routines
;===============================================================================

; 0 ( -- b )
;===============================================================================
; pushes zero (as a byte) on to the stack;
; an optimisation to avoid the number-parser
;
;-------------------------------------------------------------------------------
        .term   "0"

term_0:
        ;-----------------------------------------------------------------------
        ; normally we would call `push_byte`, but since we know the value
        ; will be zero, and the byte data-type is zero as well, we can combine
        ; them. this optimisation relies upon `TYPE_BYTE` being zero, so we
        ; sanity check this in case of unintended change in the future
        ;
        .IF TYPE_BYTE != 0
                .PRINT "TYPE_BYTE is not 0!"
                .FAIL
        .ENDIF

        ; lower the stack to make room for the byte
        .lowerStack

        ; write two zeroes:
.IFDEF  CPU_65C02
        stz zp_stack, x
        stz zp_type, x
.ELSE   ;6502
        lda # 0
        sta zp_stack, x
        sta zp_type, x
.ENDIF
        rts

; 00 ( -- w )
;===============================================================================
; pushes zero (as a word) on to the stack;
; an optimisation to avoid the number-parser
;
;-------------------------------------------------------------------------------
        .term   "00"

term_00:
        ;-----------------------------------------------------------------------
        ; push the stack pointer down twice first
        .lowerStack2
        ; write the lo/hi-byte
.IFDEF  CPU_65C02
        stz zp_stack+0, x
        stz zp_stack+1, x
.ELSE   ;6502
        lda # 0
        sta zp_stack+0, x
        sta zp_stack+1, x
.ENDIF
        ; set the word data-type
        jmp set_type_word


; +1 ( i -- i )
;===============================================================================
; add one to the integer atop the stack:
; TODO: also capture overflow
;-------------------------------------------------------------------------------
        .term   "+1"

term_add1:
        ;-----------------------------------------------------------------------
        lda zp_type, x
        bmi @word
        beq @byte

        ; a token type, including a stack underflow
        jmp err_type

        ;-----------------------------------------------------------------------
@word:  inc zp_stack, x
        bne +
        inc zp_stack+1, x
+       rts

@byte:  inc zp_stack, x
        rts


; not ( i -- i )
;===============================================================================
; flips all the bits of the integer atop the stack:
;
;-------------------------------------------------------------------------------
        .term   "not"

term_not:
        ;-----------------------------------------------------------------------
        ; read the data-type of the item atop the stack
        lda zp_type, x
        bmi @word
        beq @byte

        ; a token type, including a stack underflow
        jmp err_type

        ;-----------------------------------------------------------------------
@word:  lda zp_stack+1, x
        eor # %11111111         ; flip the hi-byte,
        sta zp_stack+1, x       ; and drop through to...

@byte:  lda zp_stack, x
        eor # %11111111         ; flip the lo-byte
        sta zp_stack, x
        
        rts


; neg ( i -- i )
;===============================================================================
; negates the integer atop the stack:
;
;-------------------------------------------------------------------------------
        .term   "neg"

term_neg:
        ;-----------------------------------------------------------------------
        ; read the data-type of the item atop the stack
        lda zp_type, x
        bmi @word
        beq @byte

        ; a token type, including a stack underflow
        jmp err_type

        ; as an optimisation, don't redo the data-type checks:
        ;-----------------------------------------------------------------------
@word:  jsr term_not@word
        jmp term_add1@word
        ;-----------------------------------------------------------------------
@byte:  jsr term_not@byte
        jmp term_add1@byte


;===============================================================================
.INC    "math_muldiv.wla"