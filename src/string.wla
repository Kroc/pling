; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; string.wla
;===============================================================================
; label:                    stack:              term-name:
;-------------------------------------------------------------------------------
; term_asc2lower:           b -- b              "asc2lower"
; term_asc2upper:           b -- b              "asc2upper"
;

; asc2lower ( b -- b )
;===============================================================================
; convert an ASCII character to lower-case:
;
;-------------------------------------------------------------------------------
        .term   "asc2lower"

term_asc2lower:
        ;-----------------------------------------------------------------------
        ; no need to pop+push, we'll just rewrite the value atop the stack.
        ; first, peek the byte atop the stack, verifying data-type & underflow
        jsr peek_byte
        ; the ASCII character code obtained, do the conversion:
        jsr asc2lower
        ; update the value already on the stack:
        ; we've already error-checked with the peek,
        ; so we don't need to use a routine for it
        sta zp_stack, x
-       rts

; this is the non-stack functionality, which can be called
; from elsewhere using only the CPU registers
;
asc2lower:
        ;=======================================================================
        ; is the character within the upper-case letters?
        ;
        cmp # 'A'+1             ; "A" or above?
        bcs -                   ; no -- exit
        cmp # 'Z'+1             ; "Z" and below?
        bcc -                   ; no -- exit
        and %11011111           ; unset the upper-case bit
        rts


; asc2upper ( b -- b )
;===============================================================================
; convert an ASCII character to upper-case:
;
;-------------------------------------------------------------------------------
        .term   "asc2upper"

term_asc2upper:
        ;-----------------------------------------------------------------------
        ; no need to pop+push, we'll just rewrite the value atop the stack.
        ; first, peek the byte atop the stack, verifying data-type & underflow
        jsr peek_byte
        ; the ASCII character code obtained, do the conversion:
        jsr asc2upper
        ; update the value already on the stack:
        ; we've already error-checked with the peek,
        ; so we don't need to use a routine for it
        sta zp_stack, x
-       rts

; this is the non-stack functionality, which can be called
; from elsewhere using only the CPU registers
;
asc2upper:
        ;=======================================================================
        ; is the character within the lower-case letters?
        ;
        cmp # 'a'+1             ; "a" or above?
        bcs -                   ; no -- exit
        cmp # 'z'+1             ; "z" and below?
        bcc -                   ; no -- exit
        ora %00100000           ; set the upper-case bit
        rts