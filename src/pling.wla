; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
;===============================================================================
.DEF    NUL             0
.DEF    LO              0
.DEF    HI              1

; import machine-specific headers:
;-------------------------------------------------------------------------------
.IFDEF  SYSTEM_CBM
        .INC    "cbm/cbm.wla"
.ENDIF
.IFDEF  CPU_65XX
        ; macros for 6502-based systems (6502, 6510, 65C02)
        ; to polyfill differences in instruction sets
        .INC    "sys_65xx.wla"
.ENDIF

; shared Pling initialisation:
;===============================================================================
pling_init:
        ;-----------------------------------------------------------------------
        ; reset Pling's stacks
        ;-----------------------------------------------------------------------
        ldy # PL_STACK_SIZE-1
-       lda # $00
        sta zp_stack, y
        lda # TOKEN_EOD
        sta zp_type, y
        dey
        bpl -
        ; put in place the stack error markers that exist at either end
        ; of the stack to automatically catch under/overflow
        lda # TOKEN_STK
        sta zp_type_und
        sta zp_type_ovr

        ; set the last term to have be defined:
        ; (this is the address of the term's header, not its code)
        lda #< _last
        ldy #> _last
        sta zp_last+LO
        sty zp_last+HI
        
        ; set the user-space starting address,
        ; where new terms will be compiled
        lda #< begin_here
        sta zp_here+LO
        lda #> begin_here
        sta zp_here+HI

        ; set the default delimiter for the interpreter (ASCII)
        lda # ' '
        sta pl_delimiter

        ; clear the term-name buffer
        lda # $00
        ldy # PL_TERM_LEN-1
-       sta pl_term_name, y
        dey
        bpl -

        ; set the data stack pointer to the starting (empty) position:
        ; note that this will not be the first item position on the stack,
        ; but the underflow position above the stack -- the stack is empty /
        ; underflowed until the first item is pushed on it
        ;
        ; from this point on, register X will be the data stack's index,
        ; unless backed up / restored by a routine
        ldx # PL_STACK_SIZE

        ; main Read, Exceute, Print Loop:
        ;=======================================================================
@repl:  jsr term_line_input
        jsr term_interpret
        jsr sys_ok

        jmp @repl

;-------------------------------------------------------------------------------
.INC    "stack.wla"             ; Pling's data/type stack routines
.INC    "error.wla"             ; error handling


; built-in terminology:
;===============================================================================
; here begins the built-in "terms" (Pling functions)

.DEF    prev_term       $0000

.MACRO  .term   ARGS    str
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
__\.\@: .WORD   prev_term
        .REDEF  prev_term       __\.\@
        .BYTE   str.length, str, NUL
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; TODO:
; the system-specific terms go first so that the code layout is weighted
; toward criticality nearest to the start, so that more and more of the
; non-system terms can be ejected, if desired, leaving a minimal runtime

.INC    "term_core.wla"         ; core native primitives
.INC    "term_math.wla"         ; core number & math routines
.INC    "term_muldiv.wla"       ; multiply & divide math
.INC    "term_string.wla"       ; core string routines
.INC    "term_stream.wla"       ; I/O streams
.INC    "term_disk.wla"         ; disk I/O

.INC    "term_print.wla"        ; printing text/data to screen
.INC    "term_interpret.wla"    ; parser, interpreter & compiler


; last-term ( -- w )
;===============================================================================
; pushes the address of the last term defined.
; used by the interpreter to begin the search for term names
;
;-------------------------------------------------------------------------------
_last:
        .term   "last-term"

term_last_term:
        ;-----------------------------------------------------------------------
        lda zp_last+LO
        ldy zp_last+HI
        jmp push_word

;===============================================================================
; WARNING: *ANY* code / data placed after this point
; will be overwritten by the compiler!
; 
begin_here: