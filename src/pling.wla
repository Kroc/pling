; pling! (c) copyright Kroc Camen 2019-2020. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
;===============================================================================
; import machine-specific headers:
;-------------------------------------------------------------------------------
.DEF    LO              0
.DEF    HI              1

.IFDEF  SYSTEM_C64
        .INC    "c64/c64.wla"
.ENDIF
.IFDEF  CPU_65XX
        ; macros for 6502-based systems (6502, 6510, 65C02)
        ; to polyfill differences in instruction sets
        .INC    "sys_65xx.wla"
.ENDIF

; data-types:
;===============================================================================
.DEF    TYPE_BYTE       %00000000       ; a data byte, but not a token!
.DEF    TYPE_WORD_LO    %10000000       ; the lo-byte of a word
.DEF    TYPE_WORD_HI    %10000001       ; the hi-byte of a word

; tokens:
;-------------------------------------------------------------------------------
; tokens are implementation-specific, opaque data types for differentiating
; error/token numbers from regular bytes/words on the stack. tokens are never
; directly exposed to Pling programs as the byte-values of tokens are not
; guaranteed to be constant, or even exist, between systems/implementations 
;
.ENUMID 1
.ENUMID TOKEN_STK       ; Stack under/overflow 
.ENUMID TOKEN_TYP       ; data-type error 
.ENUMID TOKEN_EOD       ; "End Of Data" (read / write)

;-------------------------------------------------------------------------------
.DEF    prev_term       $0000

.MACRO  .term   ARGS    str
        ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
__\.\@: .WORD   prev_term
        .REDEF  prev_term       __\.\@
        .BYTE   str.length, str, 0
        ;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; shared Pling initialisation:
;===============================================================================
pling_init:
        ;-----------------------------------------------------------------------
        ; reset Pling's stacks
        ;-----------------------------------------------------------------------
        ldy # PL_STACK_SIZE-1
-       lda # $00
        sta zp_stack, y
        lda # TOKEN_EOD
        sta zp_type, y
        dey
        bpl -
        ; put in place the stack error markers that exist at either end
        ; of the stack to automatically catch under/overflow
        lda # TOKEN_STK
        sta zp_type_und
        sta zp_type_ovr

        ; set the last term to have be defined:
        ; (this is the address of the term's header, not its code)
        lda #< _last
        ldy #> _last
        sta zp_last+LO
        sty zp_last+HI
        
        ; set the user-space starting address,
        ; where new terms will be compiled
        lda #< begin_here
        sta zp_here+LO
        lda #> begin_here
        sta zp_here+HI

        ; set the default delimiter for the interpreter (ASCII)
        lda # ' '
        sta pl_delimiter

        ; clear the term-name buffer
        lda # $00
        ldy # PL_TERM_LEN-1
-       sta pl_term_name, y
        dey
        bpl -

        ; set the data stack pointer to the starting (empty) position:
        ; note that this will not be the first item position on the stack,
        ; but the underflow position above the stack -- the stack is empty /
        ; underflowed until the first item is pushed on it
        ;
        ; from this point on, register X will be the data stack's index,
        ; unless backed up / restored by a routine
        ldx # PL_STACK_SIZE

        ;;lda # 4
        ;;jsr push_byte
        ;;lda #< @test
        ;;ldy #> @test
        ;;jsr push_word
        ;;jsr term_disk_chain

        lda #< $dead
        ldy #> $dead
        jsr push_word
        jsr term_print_hex
        lda #< $beef
        ldy #> $beef
        jsr push_word
        jsr term_print_hex
        lda # $ed
        jsr push_byte
        jsr term_print_hex
        jsr term_print_newline
        
        ;;lda # %10101010
        ;;jsr push_byte
        ;;jsr term_print_bin
        ;;jsr term_print_newline
        ;;
        ;;lda # %01010101
        ;;jsr push_byte
        ;;jsr term_print_bin
        ;;jsr term_print_newline

        lda # %10001110
        ldy # %11100011
        jsr push_word
        jsr term_print_bin
        jsr term_print_newline

-       jsr term_line_input
        jsr term_interpret

        lda # 13
        jsr sys_print
        jsr sys_print
        lda # 'O'
        jsr sys_print
        lda # 'K'
        jsr sys_print
        lda # '.'
        jsr sys_print

        jmp -

;;@test:  .ASC    "test", 0

;===============================================================================
.INC    "error.wla"             ; error handling
.INC    "stack.wla"             ; Pling's data/type stack routines
.INC    "core.wla"              ; core native primitives
.INC    "math.wla"              ; core number & math routines
.INC    "print.wla"             ; printing text/data to screen
.INC    "string.wla"            ; core string routines
.INC    "interpret.wla"         ; parser, interpreter & compiler
.INC    "stream.wla"            ; I/O streams
.INC    "disk.wla"              ; disk I/O
;;.INC    "console.wla"

; last-term ( -- w )
;===============================================================================
; pushes the address of the last term defined.
; used by the interpreter to begin the search for term names
;
;-------------------------------------------------------------------------------
_last:
        .term   "last-term"

term_last_term:
        ;-----------------------------------------------------------------------
        lda zp_last+LO
        ldy zp_last+HI
        jmp push_word

;===============================================================================
; WARNING: *ANY* code / data placed after this point
; will be overwritten by the compiler!
; 
begin_here: