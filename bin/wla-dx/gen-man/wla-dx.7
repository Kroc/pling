.\" Man page generated from reStructuredText.
.
.TH "WLA-DX" "7" "Dec 12, 2019" "9.10" "wla-dx"
.SH NAME
wla-dx \- wla-dx Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
The history behind WLA DX, from the original author, Ville Helin:
.INDENT 0.0
.INDENT 3.5
I wrote this because I had never written an assembler before and I really
needed a macro assembler which could compile the GB\-Z80 code I wrote. ;)
Gaelan Griffin needed real Z80 support for his SMS projects so I thought
I could write WLA to be a little more open and nowadays it supports all
the Z80 systems you can think of. You\(aqll just have to define the memorymap
of the destination machine for your project. After fixing some bugs I thought
I could add support for 6502 systems so all NES\-people would get their
share of WLA as well. After finishing that few people said they\(aqd like 65816
support (they had SNES developing in mind) so I added support for that. And
then I thought I should write a 6510 version of WLA as well...
.sp
This is my ideal GB\-Z80 macro assembler (not in final form, not yet). ;)
Tastes differ. Thus WLA! Notice that WLA was initially made for Game Boy
developers so the GB\-Z80 version and the rest differ a little.
.UNINDENT
.UNINDENT
.sp
Good to know about WLA DX:
.sp
Almost all rules that apply to Z80 source code processing with WLA DX
apply also to 6502, 65C02, 6510, 65816, 6800, 6801, 6809, 8008, 8080,
HUC6280 and SPC\-700.
.sp
About the names: WLA DX means all the tools covered in this documentation.
So WLA DX includes WLA GB\-Z80/Z80/6502/65C02/6510/65816/6800/6801/6809/8008/
8080/HUC6280/SPC\-700 macro assembler (what a horribly long name), WLAB,
and WLALINK GB\-Z80/Z80/6502/65C02/6510/65816/6800/6801/6809/8008/8080/
HUC6280/SPC\-700 linker. We use plain WLA to refer to the macro assembler
in this document.
.sp
There was WLAD, an GB\-Z80 dissassembler, but it has been discontinued and
removed from the project and the documentation.
.sp
Currently WLA can also be used as a patch tool. Just include the original
ROM image into the project with \fB\&.BACKGROUND\fP and insert e.g.,
\fBOVERWRITE .SECTION\fP s to patch the desired areas. Output the data into a new
ROM image and there you have it. 100% readable (asm coded) patches are reality!
.sp
Note that you can directly compile only object and library files. You must
use WLALINK to link these (or only one, if you must) into a ROM/program file.
.nf
WLA DX\(aqs old homepage: \fI\%http://www.iki.fi/~vhelin/wla.html\fP
WLA DX\(aqs new homepage: \fI\%https://github.com/vhelin/wla\-dx\fP
.fi
.sp
.sp
Here\(aqs the order in which the data is placed into the output:
.INDENT 0.0
.IP 1. 3
Data and group 3 directives outside sections.
.IP 2. 3
Group 2 directives.
.IP 3. 3
Data and group 3 directives inside sections.
.IP 4. 3
Group 1 directives.
.UNINDENT
.TS
center;
|l|l|.
_
T{
ALL
T}	T{
All, GB\-Z80, Z80, 6502, 65C02, 6510, 65816, HUC6280, SPC\-700,
6800, 6801, 6809, 8008 and 8080 versions apply.
T}
_
T{
GB
T}	T{
Only the GB\-Z80 version applies.
T}
_
T{
GB8
T}	T{
Only the GB\-Z80 and 65816 versions apply.
T}
_
T{
Z80
T}	T{
Only the Z80 version applies.
T}
_
T{
658
T}	T{
Only the 65816 version applies.
T}
_
T{
680
T}	T{
Only the 6800, 6801 and 6809 versions apply.
T}
_
T{
800
T}	T{
Only the 8008 version applies.
T}
_
T{
808
T}	T{
Only the 8080 version applies.
T}
_
T{
SPC
T}	T{
Only the SPC\-700 version applies.
T}
_
T{
65x
T}	T{
Only the 6502, 65C02, 6510, 65816 and HUC6280 versions apply.
T}
_
T{
!GB
T}	T{
Only the Z80, 6502, 65C02, 6510, 65816, HUC6280 and SPC\-700
versions apply.
T}
_
.TE
.sp
Group 1:
.TS
center;
|l|l|.
_
T{
GB
T}	T{
\fB\&.COMPUTEGBCHECKSUM\fP
T}
_
T{
Z80
T}	T{
\fB\&.COMPUTESMSCHECKSUM\fP
T}
_
T{
658
T}	T{
\fB\&.COMPUTESNESCHECKSUM\fP
T}
_
T{
Z80
T}	T{
\fB\&.SDSCTAG 1.0, "DUNGEON MAN", "A wild dungeon exploration game", "Ville Helin"\fP
T}
_
T{
Z80
T}	T{
\fB\&.SMSTAG\fP
T}
_
.TE
.sp
Group 2:
.TS
center;
|l|l|.
_
T{
GB
T}	T{
\fB\&.CARTRIDGETYPE 1\fP
T}
_
T{
GB
T}	T{
\fB\&.COUNTRYCODE 1\fP
T}
_
T{
GB
T}	T{
\fB\&.VERSION 1\fP
T}
_
T{
GB
T}	T{
\fB\&.DESTINATIONCODE 1\fP
T}
_
T{
GB
T}	T{
\fB\&.NINTENDOLOGO\fP
T}
_
T{
GB
T}	T{
\fB\&.GBHEADER\fP
T}
_
T{
Z80
T}	T{
\fB\&.SMSHEADER\fP
T}
_
T{
GB
T}	T{
\fB\&.COMPUTEGBCOMPLEMENTCHECK\fP
T}
_
T{
ALL
T}	T{
\fB\&.EMPTYFILL $C9\fP
T}
_
T{
658
T}	T{
\fB\&.ENDEMUVECTOR\fP
T}
_
T{
658
T}	T{
\fB\&.ENDNATIVEVECTOR\fP
T}
_
T{
658
T}	T{
\fB\&.ENDSNES\fP
T}
_
T{
ALL
T}	T{
\fB\&.EXPORT work_x\fP
T}
_
T{
658
T}	T{
\fB\&.FASTROM\fP
T}
_
T{
658
T}	T{
\fB\&.HIROM\fP
T}
_
T{
658
T}	T{
\fB\&.EXHIROM\fP
T}
_
T{
GB
T}	T{
\fB\&.LICENSEECODENEW "1A"\fP
T}
_
T{
GB
T}	T{
\fB\&.LICENSEECODEOLD $1A\fP
T}
_
T{
658
T}	T{
\fB\&.LOROM\fP
T}
_
T{
GB8
T}	T{
\fB\&.NAME "NAME OF THE ROM"\fP
T}
_
T{
ALL
T}	T{
\fB\&.OUTNAME "other.o"\fP
T}
_
T{
GB
T}	T{
\fB\&.RAMSIZE 0\fP
T}
_
T{
GB
T}	T{
\fB\&.ROMDMG\fP
T}
_
T{
GB
T}	T{
\fB\&.ROMGBC\fP
T}
_
T{
GB
T}	T{
\fB\&.ROMGBCONLY\fP
T}
_
T{
GB
T}	T{
\fB\&.ROMSGB\fP
T}
_
T{
658
T}	T{
\fB\&.SLOWROM\fP
T}
_
T{
658
T}	T{
\fB\&.SMC\fP
T}
_
T{
658
T}	T{
\fB\&.SNESEMUVECTOR\fP
T}
_
T{
658
T}	T{
\fB\&.SNESHEADER\fP
T}
_
T{
658
T}	T{
\fB\&.SNESNATIVEVECTOR\fP
T}
_
.TE
.sp
Group 3:
.TS
center;
|l|l|.
_
T{
65x
T}	T{
\fB\&.16BIT\fP
T}
_
T{
658
T}	T{
\fB\&.24BIT\fP
T}
_
T{
65x
T}	T{
\fB\&.8BIT\fP
T}
_
T{
658
T}	T{
\fB\&.ACCU 8\fP
T}
_
T{
ALL
T}	T{
\fB\&.ASC "HELLO WORLD!"\fP
T}
_
T{
ALL
T}	T{
\fB\&.ASCTABLE\fP
T}
_
T{
ALL
T}	T{
\fB\&.ASCIITABLE\fP
T}
_
T{
ALL
T}	T{
\fB\&.ASM\fP
T}
_
T{
ALL
T}	T{
\fB\&.BACKGROUND "parallax.gb"\fP
T}
_
T{
ALL
T}	T{
\fB\&.BANK 0 SLOT 1\fP
T}
_
T{
ALL
T}	T{
\fB\&.BASE $80\fP
T}
_
T{
ALL
T}	T{
\fB\&.BLOCK "Block1"\fP
T}
_
T{
ALL
T}	T{
\fB\&.BR\fP
T}
_
T{
ALL
T}	T{
\fB\&.BREAKPOINT\fP
T}
_
T{
ALL
T}	T{
\fB\&.BYT 100, $30, %1000, "HELLO WORLD!"\fP
T}
_
T{
ALL
T}	T{
\fB\&.DATA $ff00, 2\fP
T}
_
T{
ALL
T}	T{
\fB\&.DB 100, $30, %1000, "HELLO WORLD!"\fP
T}
_
T{
ALL
T}	T{
\fB\&.DBM filtermacro 1, 2, "encrypt me"\fP
T}
_
T{
ALL
T}	T{
\fB\&.DBCOS 0.2, 10, 3.2, 120, 1.3\fP
T}
_
T{
ALL
T}	T{
\fB\&.DBRND 20, 0, 10\fP
T}
_
T{
ALL
T}	T{
\fB\&.DBSIN 0.2, 10, 3.2, 120, 1.3\fP
T}
_
T{
ALL
T}	T{
\fB\&.DEFINE IF $FF0F\fP
T}
_
T{
ALL
T}	T{
\fB\&.DEF IF $FF0F\fP
T}
_
T{
658
T}	T{
\fB\&.DL $102030, $405060\fP
T}
_
T{
ALL
T}	T{
\fB\&.DS 256, $10\fP
T}
_
T{
ALL
T}	T{
\fB\&.DSB 256, $10\fP
T}
_
T{
658
T}	T{
\fB\&.DSL 16, $102030\fP
T}
_
T{
ALL
T}	T{
\fB\&.DSTRUCT waterdrop INSTANCEOF water DATA "tingle", 40, 120\fP
T}
_
T{
ALL
T}	T{
\fB\&.DSW 128, 20\fP
T}
_
T{
ALL
T}	T{
\fB\&.DW 16000, 10, 255\fP
T}
_
T{
ALL
T}	T{
\fB\&.DWM filtermacro 1, 2, 3\fP
T}
_
T{
ALL
T}	T{
\fB\&.DWCOS 0.2, 10, 3.2, 1024, 1.3\fP
T}
_
T{
ALL
T}	T{
\fB\&.DWRND 20, 0, 10\fP
T}
_
T{
ALL
T}	T{
\fB\&.DWSIN 0.2, 10, 3.2, 1024, 1.3\fP
T}
_
T{
ALL
T}	T{
\fB\&.ELSE\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDA\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDASM\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDB\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDE\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDIF\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDM\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDME\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDR\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDRO\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDS\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDST\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENDU\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENUM $C000\fP
T}
_
T{
ALL
T}	T{
\fB\&.ENUMID ID_1 0\fP
T}
_
T{
ALL
T}	T{
\fB\&.EQU IF $FF0F\fP
T}
_
T{
ALL
T}	T{
\fB\&.FAIL\fP
T}
_
T{
ALL
T}	T{
\fB\&.FCLOSE FP_DATABIN\fP
T}
_
T{
ALL
T}	T{
\fB\&.FOPEN "data.bin" FP_DATABIN\fP
T}
_
T{
ALL
T}	T{
\fB\&.FREAD FP_DATABIN DATA\fP
T}
_
T{
ALL
T}	T{
\fB\&.FSIZE FP_DATABIN SIZE\fP
T}
_
T{
ALL
T}	T{
\fB\&.IF DEBUG == 2\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFDEF IF\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFDEFM \e2\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFEQ DEBUG 2\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFEXISTS "main.s"\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFGR DEBUG 2\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFGREQ DEBUG 1\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFLE DEBUG 2\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFLEEQ DEBUG 1\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFNDEF IF\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFNDEFM \e2\fP
T}
_
T{
ALL
T}	T{
\fB\&.IFNEQ DEBUG 2\fP
T}
_
T{
ALL
T}	T{
\fB\&.INCBIN "sorority.bin"\fP
T}
_
T{
ALL
T}	T{
\fB\&.INCDIR "/usr/programming/gb/include/"\fP
T}
_
T{
ALL
T}	T{
\fB\&.INCLUDE "cgb_hardware.i"\fP
T}
_
T{
658
T}	T{
\fB\&.INDEX 8\fP
T}
_
T{
ALL
T}	T{
\fB\&.INPUT NAME\fP
T}
_
T{
658
T}	T{
\fB\&.LONG $102030, $405060\fP
T}
_
T{
658
T}	T{
\fB\&.FARADDR main, irq_1\fP
T}
_
T{
ALL
T}	T{
\fB\&.MACRO TEST\fP
T}
_
T{
ALL
T}	T{
\fB\&.MEMORYMAP\fP
T}
_
T{
ALL
T}	T{
\fB\&.NEXTU name\fP
T}
_
T{
ALL
T}	T{
\fB\&.ORG $150\fP
T}
_
T{
ALL
T}	T{
\fB\&.ORGA $150\fP
T}
_
T{
ALL
T}	T{
\fB\&.PRINT "Numbers 1 and 10: ", DEC 1, " $", HEX 10, "\en"\fP
T}
_
T{
ALL
T}	T{
\fB\&.PRINTT "Here we are...\en"\fP
T}
_
T{
ALL
T}	T{
\fB\&.PRINTV DEC DEBUG+1\fP
T}
_
T{
ALL
T}	T{
\fB\&.RAMSECTION "Vars" BANK 0 SLOT 1 ALIGN 4\fP
T}
_
T{
ALL
T}	T{
\fB\&.REDEFINE IF $F\fP
T}
_
T{
ALL
T}	T{
\fB\&.REDEF IF $F\fP
T}
_
T{
ALL
T}	T{
\fB\&.REPEAT 6\fP
T}
_
T{
ALL
T}	T{
\fB\&.REPT 6\fP
T}
_
T{
ALL
T}	T{
\fB\&.ROMBANKMAP\fP
T}
_
T{
ALL
T}	T{
\fB\&.ROMBANKS 2\fP
T}
_
T{
ALL
T}	T{
\fB\&.ROMBANKSIZE $4000\fP
T}
_
T{
ALL
T}	T{
\fB\&.ROW $ff00, 1, "3"\fP
T}
_
T{
ALL
T}	T{
\fB\&.SEED 123\fP
T}
_
T{
ALL
T}	T{
\fB\&.SECTION "Init" FORCE\fP
T}
_
T{
ALL
T}	T{
\fB\&.SHIFT\fP
T}
_
T{
ALL
T}	T{
\fB\&.SLOT 1\fP
T}
_
T{
ALL
T}	T{
\fB\&.STRUCT enemy_object\fP
T}
_
T{
ALL
T}	T{
\fB\&.SYM SAUSAGE\fP
T}
_
T{
ALL
T}	T{
\fB\&.SYMBOL SAUSAGE\fP
T}
_
T{
ALL
T}	T{
\fB\&.TABLE byte, word, byte\fP
T}
_
T{
ALL
T}	T{
\fB\&.UNBACKGROUND $1000 $1FFF\fP
T}
_
T{
ALL
T}	T{
\fB\&.UNDEFINE DEBUG\fP
T}
_
T{
ALL
T}	T{
\fB\&.UNDEF DEBUG\fP
T}
_
T{
ALL
T}	T{
\fB\&.UNION name\fP
T}
_
T{
ALL
T}	T{
\fB\&.WORD 16000, 10, 255\fP
T}
_
T{
ALL
T}	T{
\fB\&.ADDR 16000, main, 255\fP
T}
_
.TE
.sp
Descriptions:
.SH .ENUMID ID_1 0
.sp
\fB\&.ENUMID\fP will create definitions with an autoincrementing value.
For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ENUMID 0
\&.ENUMID ID_1
\&.ENUMID ID_2
\&.ENUMID ID_3
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\&... will create the following definitions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ID_1 = 0
ID_2 = 1
ID_3 = 2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can also specify the adder:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ENUMID 0 STEP 2
\&.ENUMID MONSTER_ID_1
\&.ENUMID MONSTER_ID_2
\&.ENUMID MONSTER_ID_3
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\&... to create definitions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
MONSTER_ID_1 = 0
MONSTER_ID_2 = 2
MONSTER_ID_3 = 4
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you wish to export the definitions automatically, use EXPORT:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ENUMID 16 STEP 2 EXPORT
\&.ENUMID MUSIC_1
\&.ENUMID MUSIC_2
\&.ENUMID MUSIC_3
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\&... will create the following definitions and export them all:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
MUSIC_1 = 16
MUSIC_2 = 18
MUSIC_3 = 20
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .TABLE BYTE, WORD, BYTE
.sp
Defines table\(aqs columns. With .DATA and .ROW you can define data much
like using .DB or .DW, but .TABLE makes it convenient to feed big
amounts of data in mixed format.
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.TABLE byte, word, byte
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the columns have been defined, you can define rows using e.g.,
.INDENT 0.0
.INDENT 3.5
\&.ROW $01, $0302, $04
.UNINDENT
.UNINDENT
.sp
This is the same as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DB $01
\&.DW $0302
\&.DB $04
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that .DATA can also be used instead of .ROW, if one wants to
give the data in pieces.
.INDENT 0.0
.TP
.B All supported column formats:
.INDENT 7.0
.IP \(bu 2
DB, BYT, BYTE
.IP \(bu 2
DW, WORD, ADDR
.IP \(bu 2
DL, LONG, FARADDR ; wla\-65816 only
.IP \(bu 2
DS, DSB
.IP \(bu 2
DSW
.IP \(bu 2
DSL               ; wla\-65816 only
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .ROW $FF00, 1, "3"
.sp
Defines bytes after a .TABLE has been used to define the format.
An alternative way of defining bytes to .DB/.DW.
.sp
Note that when you use .ROW you\(aqll need to give all the items
.TABLE defines, i.e. one full row. To give more or less bytes
use .DATA.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.TABLE word, byte, word
\&.ROW $aabb, "H", $ddee
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is the same as
.INDENT 0.0
.INDENT 3.5
\&.DW $aabb
.DB "H"
.DW $ddee
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .DATA $FF00, 2
.sp
Defines bytes after a .TABLE has been used to define the format.
An alternative way of defining bytes to .DB/.DW.
.sp
Note that when you use .DATA you can give as many items .TABLE
defines. The next time you\(aqll use .DATA you\(aqll continue from
the point the previous .DATA ended.
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.TABLE dsw 2, dsb 2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This defines two rows worth of bytes:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DATA $ff00, $aabb, $10, $20, $1020, $3040, $50, $60
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This does the same:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DATA $ff00, $aabb
\&.DATA $10, $20
\&.DATA $1020, $3040
\&.DATA $50, $60
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .8BIT
.sp
There are a few mnemonics that look identical, but take different sized
arguments. Here\(aqs a list of such 6502 mnemonics:
.sp
ADC, AND, ASL, BIT, CMP, CPX, CPY, DEC, EOR, INC, LDA, LDX, LDY, ORA, ROL,
SBC, STA, STX and STY.
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11       ; $46 $0B
LSR $A000    ; $4E $00 $A0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The first one could also be
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11       ; $4E $0B $00
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\&.8BIT\fP is here to help WLA to decide to choose which one of the opcodes it
selects. When you give \fB\&.8BIT\fP (default) no 8\-bit address/value is expanded
to 16\-bits.
.sp
By default WLA uses the smallest possible size. This is true also when WLA
finds a computation it can\(aqt solve right away. WLA assumes the result will
be inside the smallest possible bounds, which depends on the type of the
mnemonic.
.sp
You can also use the fixed argument size versions of such mnemonics by
giving the size with the operand (i.e., operand hinting). Here are few
examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11.B   ; $46 $0B
LSR 11.W   ; $4E $0B $00
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In WLA\-65816 \fB\&.ACCU\fP/\fB\&.INDEX\fP/\fBSEP\fP/\fBREP\fP override
\fB\&.8BIT\fP/\fB\&.16BIT\fP/\fB\&.24BIT\fP when considering the immediate values, so be
careful. Still, operand hints override all of these, so use them to be sure.
.sp
This is not a compulsory directive.
.SH .16BIT
.sp
Analogous to \fB\&.8BIT\fP\&. \fB\&.16BIT\fP forces all addresses and immediate values to
be expanded into 16\-bit range, when possible, that is.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11       ; $46 $0B
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
that would be the case, normally, but after \fB\&.16BIT\fP it becomes
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11       ; $4E $0B $00
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .24BIT
.sp
Analogous to \fB\&.8BIT\fP and \fB\&.16BIT\fP\&. \fB\&.24BIT\fP forces all addresses to
be expanded into 24\-bit range, when possible, that is.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND $11       ; $25 $11
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
that would be the case, normally, but after \fB\&.24BIT\fP it becomes
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND $11       ; $2F $11 $00 $00
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If it is not possible to expand the address into \fB\&.24BIT\fP range,
then WLA tries to expand it into 16\-bit range.
.sp
This is not a compulsory directive.
.SH .ACCU 8
.sp
Forces WLA to override the accumulator size given with \fBSEP\fP/\fBREP\fP\&.
\fB\&.ACCU\fP doesn\(aqt produce any code, it only affects the way WLA interprets the
immediate values (8 for 8 bit operands, 16 for 16 bit operands) for opcodes
dealing with the accumulator.
.sp
So after giving \fB\&.ACCU 8\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND #6
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will produce \fB$29 $06\fP, and after giving \fB\&.ACCU 16\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND #6
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will yield \fB$29 $00 $06\fP\&.
.sp
Note that \fBSEP\fP/\fBREP\fP again will in turn reset the accumulator/index
register size.
.sp
This is not a compulsory directive.
.SH .INDEX 8
.sp
Forces WLA to override the index (\fBX\fP/\fBY\fP) register size given with
\fBSEP\fP/\fBREP\fP\&. \fB\&.INDEX\fP doesn\(aqt produce any code, it only affects the way
WLA interprets the immediate values (\fB8\fP for 8 bit operands, \fB16\fP for 16
bit operands) for opcodes dealing with the index registers.
.sp
So after giving \fB\&.INDEX 8\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
CPX #10
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will produce \fB$E0 $A0\fP, and after giving \fB\&.INDEX 16\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
CPX #10
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will yield \fB$E0 $00 $A0\fP\&.
.sp
Note that \fBSEP\fP/\fBREP\fP again will in turn reset the accumulator/index
register size.
.sp
This is not a compulsory directive.
.SH .ASM
.sp
Tells WLA to start assembling. Use \fB\&.ASM\fP to continue the work which has been
disabled with \fB\&.ENDASM\fP\&. \fB\&.ASM\fP and \fB\&.ENDASM\fP can be used to mask away
big blocks of code. This is analogous to the ANSI C \-comments (\fB/*...*/\fP),
but \fB\&.ASM\fP and \fB\&.ENDASM\fP can be nested, unlike the ANSI C \-counterpart.
.sp
This is not a compulsory directive.
.SH .ENDASM
.sp
Tells WLA to stop assembling. Use \fB\&.ASM\fP to continue the work.
.sp
This is not a compulsory directive.
.SH .DBRND 20, 0, 10
.sp
Defines bytes, just like \fB\&.DSB\fP does, only this time they are filled with
(pseudo) random numbers. We use the integrated Mersenne Twister to generate
the random numbers. If you want to seed the random number generator,
use \fB\&.SEED\fP\&.
.sp
The first parameter (\fB20\fP in the example) defines the number of random
numbers we want to generate. The next two tell the range of the random
numbers, i.e. min and max.
.sp
Here\(aqs how it works:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DBRND A, B, C

for (i = 0; i < A; i++)
  output_data((rand() % (C\-B+1)) + B);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .DWRND 20, 0, 10
.sp
Analogous to \fB\&.DBRND\fP (but defines words).
.sp
This is not a compulsory directive.
.SH .DBCOS 0.2, 10, 3.2, 120, 1.3
.sp
Defines bytes just like \fB\&.DSB\fP does, only this time they are filled with
cosine data. \fB\&.DBCOS\fP takes five arguments.
.sp
The first argument is the starting angle. Angle value ranges from \fB0\fP to
\fB359.999\fP\&..., but you can supply WLA with values that are out of the range \-
WLA fixes them ok. The value can be integer or float.
.sp
The second one descibes the amount of additional angles. The example
will define 11 angles.
.sp
The third one is the adder value which is added to the angle value when
next angle is calculated. The value can be integer or float.
.sp
The fourth and fifth ones can be seen from the pseudo code below, which
also describes how \fB\&.DBCOS\fP works. The values can be integer or float.
.sp
Remember that \fBcos\fP (and \fBsin\fP) here returns values ranging from
\fB\-1\fP to \fB1\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DBCOS A, B, C, D, E

for (B++; B > 0; B\-\-) {
  output_data((D * cos(A)) + E)
  A = keep_in_range(A + C)
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .DBSIN 0.2, 10, 3.2, 120, 1.3
.sp
Analogous to \fB\&.DBCOS\fP, but does \fBsin()\fP instead of \fBcos()\fP\&.
.sp
This is not a compulsory directive.
.SH .DWCOS 0.2, 10, 3.2, 1024, 1.3
.sp
Analogous to \fB\&.DBCOS\fP (but defines words).
.sp
This is not a compulsory directive.
.SH .DWSIN 0.2, 10, 3.2, 1024, 1.3
.sp
Analogous to \fB\&.DBCOS\fP (but defines words and does \fBsin()\fP instead of
\fBcos()\fP).
.sp
This is not a compulsory directive.
.SH .NAME "NAME OF THE ROM"
.sp
If \fB\&.NAME\fP is used with WLA\-GB then the 16 bytes ranging from \fB$0134\fP
to \fB$0143\fP are filled with the provided string. WLA\-65816 fills
the 21 bytes from \fB$FFC0\fP to \fB$FFD4\fP in HiROM and from \fB$7FC0\fP to
\fB$7FD4\fP in LoROM mode with the name string (SNES ROM title). For ExHiROM
the ranges are from \fB$40FFC0\fP to \fB$40FFD4\fP and from \fB$FFC0\fP to \fB$FFD4\fP
(mirrored).
.sp
If the string is shorter than 16/21 bytes the remaining space is
filled with \fB$00\fP\&.
.sp
This is not a compulsory directive.
.SH .ROMBANKS 2
.sp
Indicates the size of the ROM in rombanks. This value is converted to a
standard Gameboy ROM size indicator value found at \fB$148\fP in a Gameboy ROM,
and there this one is put into.
.sp
This is a compulsory directive unless \fB\&.ROMBANKMAP\fP is defined.
.sp
You can redefine \fB\&.ROMBANKS\fP as many times as you wish as long as
the old and the new ROM bank maps match as much as possible. This
way you can enlarge the size of the project on the fly.
.SH .RAMSIZE 0
.sp
Indicates the size of the RAM. This is a standard Gameboy RAM size indicator
value found at \fB$149\fP in a Gameboy ROM, and there this one is put to also.
.sp
This is not a compulsory directive.
.SH .EMPTYFILL $C9
.sp
This byte is used in filling the unused areas of the ROM file. \fBEMPTYFILL\fP
defaults to \fB$00\fP\&.
.sp
This is not a compulsory directive.
.SH .CARTRIDGETYPE 1
.sp
Indicates the type of the cartridge (mapper and so on). This is a standard
Gameboy cartridge type indicator value found at \fB$147\fP in a Gameboy ROM, and
there this one is put to also.
.sp
This is not a compulsory directive.
.SH .COUNTRYCODE 1
.sp
Indicates the country code located at \fB$14A\fP of a Gameboy ROM.
.sp
This is not a compulsory directive.
.SH .VERSION 1
.sp
Indicates the Mask ROM version number located at \fB$14C\fP of a Gameboy ROM.
.sp
This is not a compulsory directive.
.SH .DESTINATIONCODE 1
.sp
\fB\&.DESTINATIONCODE\fP is an alias for \fB\&.COUNTRYCODE\fP\&.
.sp
This is not a compulsory directive.
.SH .NINTENDOLOGO
.sp
Places the required Nintendo logo into the Gameboy ROM at \fB$104\fP\&.
.sp
This is not a compulsory directive.
.SH .GBHEADER
.sp
This begins the GB header definition, and automatically defines
\fB\&.COMPUTEGBCHECKSUM\fP\&. End the header definition with .ENDGB.
Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.GBHEADER
    NAME "TANKBOMBPANIC"  ; identical to a freestanding .NAME.
    LICENSEECODEOLD $34   ; identical to a freestanding .LICENSEECODEOLD.
    LICENSEECODENEW "HI"  ; identical to a freestanding .LICENSEECODENEW.
    CARTRIDGETYPE $00     ; identical to a freestanding .CARTRIDGETYPE.
    RAMSIZE $09           ; identical to a freestanding .RAMSIZE.
    COUNTRYCODE $01       ; identical to a freestanding .COUNTRYCODE/DESTINATIONCODE.
    DESTINATIONCODE $01   ; identical to a freestanding .DESTINATIONCODE/COUNTRYCODE.
    NINTENDOLOGO          ; identical to a freestanding .NINTENDOLOGO.
    VERSION $01           ; identical to a freestanding .VERSION.
    ROMDMG                ; identical to a freestanding .ROMDMG.
                          ; Alternatively, ROMGBC or ROMGBCONLY can be used
\&.ENDGB
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .SMSHEADER
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SMSHEADER
    PRODUCTCODE 26, 70, 2 ; 2.5 bytes
    VERSION 1             ; 0\-15
    REGIONCODE 4          ; 3\-7
    RESERVEDSPACE 0, 0    ; 2 bytes
\&.ENDSMS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBREGIONCODE\fP also defines the system:
.TS
center;
|l|l|.
_
T{
\fB3\fP
T}	T{
SMS Japan
T}
_
T{
\fB4\fP
T}	T{
SMS Export
T}
_
T{
\fB5\fP
T}	T{
GG Japan
T}
_
T{
\fB6\fP
T}	T{
GG Export
T}
_
T{
\fB7\fP
T}	T{
GG International
T}
_
.TE
.sp
When \fB\&.SMSHEADER\fP is defined, also the checksum is calculated, and TMR SEGA,
two reserved bytes and ROM size are defined.
.sp
See \fI\%http://www.smspower.org/Development/ROMHeader\fP for more information about
SMS header.
.sp
This is not a compulsory directive.
.SH .LICENSEECODEOLD $1A
.sp
This is a standard old licensee code found at \fB$14B\fP in a Gameboy ROM, and there
this one is put to also. \fB\&.LICENSEECODEOLD\fP cannot be defined with
\fB\&.LICENSEECODENEW\fP\&.
.sp
This is not a compulsory directive.
.SH .LICENSEECODENEW "1A"
.sp
This is a standard new licensee code found at \fB$144\fP and \fB$145\fP in a
Gameboy ROM, and there this one is put to also. \fB\&.LICENSEECODENEW\fP cannot be
defined with .LICENSEECODEOLD. \fB$33\fP is inserted into \fB$14B\fP, as well.
.sp
This is not a compulsory directive.
.SH .COMPUTEGBCHECKSUM
.sp
When this directive is used WLA computes the ROM checksum found at \fB$14E\fP and
\fB$14F\fP in a Gameboy ROM. Note that this directive can only be used with
WLA\-GB.
.sp
Note that you can also write \fB\&.COMPUTECHECKSUM\fP (the old name for this
directive), but it\(aqs not recommended.
.sp
This is not a compulsory directive.
.SH .COMPUTESMSCHECKSUM
.sp
When this directive is used WLA computes the ROM checksum found at \fB$7FFA\fP
and \fB$7FFB\fP (or \fB$3FFA\fP \- \fB$3FFB\fP is the ROM is 16KBs, or
\fB$1FFA\fP \- \fB$1FFB\fP for 8KB ROMs) in a SMS/GG ROM. Note that this directive
can only be used with WLA\-z80. Also note that the ROM size must be at least
8KBs. The checksum is calculated using bytes
\fB0x0000\fP \- \fB0x1FEF\fP/\fB0x3FEF\fP/\fB0x7FEF\fP\&.
.sp
This is not a compulsory directive.
.SH .COMPUTESNESCHECKSUM
.sp
When this directive is used WLA computes the SNES ROM checksum and
inverse checksum found at \fB$7FDC\fP \- \fB$7FDF\fP (LoROM), \fB$FFDC\fP \- \fB$FFDF\fP
(HiROM) or \fB$40FFDC\fP \- \fB$40FFDF\fP and \fB$FFDC\fP \- \fB$FFDF\fP (ExHiROM).
Note that this directive can only be used with WLA\-65816. Also note
that the ROM size must be at least 32KB for LoROM images, 64KB for
HiROM images and 32.5MBit for ExHiROM.
.sp
\fB\&.LOROM\fP, \fB\&.HIROM\fP or \fB\&.EXHIROM\fP must be issued before \fB\&.COMPUTESNESCHECKSUM\fP\&.
.sp
This is not a compulsory directive.
.SH .SMSTAG
.sp
\fB\&.SMSTAG\fP forces WLA to write an ordinary SMS/GG ROM tag to the ROM file.
Currently only the string \fBTMR SEGA\fP and ROM checksum are written
(meaning that \fB\&.SMSTAG\fP also defines \fB\&.COMPUTESMSCHECKSUM\fP). The ROM size
must be at least 8KBs.
.sp
This is not a compulsory directive.
.SH .SDSCTAG 1.0, "DUNGEON MAN", "A WILD DUNGEON EXPLORATION GAME", "VILLE HELIN"
.sp
\fB\&.SDSCTAG\fP adds SDSC tag to your SMS/GG ROM file. The ROM size must be at
least 8KB just like with \fB\&.COMPUTESMSCHECKSUM\fP and \fB\&.SMSTAG\fP\&. For more
information about this header take a look at \fI\%http://www.smspower.org/dev/sdsc/\fP\&.
Here\(aqs an explanation of the arguments:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SDSCTAG {version number}, {program name}, {program release notes}, {program author}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that program name, release notes and program author can also be pointers
to strings instead of being only strings (which WLA terminates with zero, and
places them into suitable locations inside the ROM file). So
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SDSCTAG 0.8, PRGNAME, PRGNOTES, PRGAUTHOR
\&...
PRGNAME:  .DB "DUNGEON MAN", 0
PRGNOTES: .DB "A wild and totally crazy dungeon exploration game", 0
PRGAUTHOR:.DB "Ville Helin", 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
works also. All strings supplied explicitly to \fB\&.SDSCTAG\fP are placed
somewhere in \fB\&.BANK 0 SLOT 0\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SDSCTAG 1.0, "", "", ""
\&.SDSCTAG 1.0, 0, 0, 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
are also valid, here \fB0\fP and \fB""\fP mean the user doesn\(aqt want to use any
descriptive strings. Version number can also be given as an integer, but then
the minor version number defaults to zero.
.sp
\fB\&.SDSCTAG\fP also defines \fB\&.SMSTAG\fP (as it\(aqs part of the SDSC ROM tag
specification).
.sp
This is not a compulsory directive.
.SH .COMPUTEGBCOMPLEMENTCHECK
.sp
When this directive is used WLA computes the ROM complement check found at
\fB$14D\fP in a Gameboy ROM.
.sp
Note that you can still use \fB\&.COMPUTECOMPLEMENTCHECK\fP (the old name for this
directive), but it\(aqs not recommended.
.sp
This is not a compulsory directive.
.SH .INCDIR "/USR/PROGRAMMING/GB/INCLUDE/"
.sp
Changes the current include root directory. Use this to specify main
directory for the following \fB\&.INCLUDE\fP and \fB\&.INCBIN\fP directives.
If you want to change to the current working directory (WLA also defaults
to this), use
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.INCDIR ""
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If the \fBINCDIR\fP is specified in the command line, that directory will be
searched before the \fB\&.INCDIR\fP in the file. If the file is not found, WLA
will then silently search the specified \fB\&.INCDIR\fP\&.
.sp
This is not a compulsory directive.
.SH .INCLUDE "CGB_HARDWARE.I"
.sp
Includes the specified file to the source file. If the file\(aqs not found
in the \fB\&.INCDIR\fP directory, WLA tries to find it in the current working
directory. If the \fBINCDIR\fP is specified in the command line, WLA will first
try to find the file specified in that directory. Then proceed as mentioned
before if it is not found.
.sp
This is not a compulsory directive.
.SH .INCBIN "SORORITY.BIN"
.sp
Includes the specified data file into the source file. \fB\&.INCBIN\fP caches
all files into memory, so you can \fB\&.INCBIN\fP any data file millions of
times, but it is loaded from hard drive only once.
.sp
You can optionally use \fBSWAP\fP after the file name, e.g.,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.INCBIN "kitten.bin" SWAP
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\&.INCBIN\fP data is divided into blocks of two bytes, and inside every block
the bytes are exchanged (like \fBSWAP r\fP does to nibbles). This requires that
the size of the file is even.
.sp
You can also force WLA to skip n bytes from the beginning of the file
by writing for example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.INCBIN "kitten.bin" SKIP 4
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Four bytes are skipped from the beginning of \fBkitten.bin\fP and the rest
is incbinned.
.sp
It is also possible to incbin only n bytes from a file:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.INCBIN "kitten.bin" READ 10
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Will read ten bytes from the beginning of \fBkitten.bin\fP\&.
.sp
You can also force WLA to create a definition holding the size
of the file:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.INCBIN "kitten.bin" FSIZE size_of_kitten
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Want to circulate all the included bytes through a filter macro? Do this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.INCBIN "kitten.bin" FILTER filtermacro
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The filter macro is executed for each byte of the included data, data
byte being the first argument, and offset from the beginning being the
second parameter, just like in the case of \fB\&.DBM\fP and \fB\&.DWM\fP\&.
.sp
And you can combine all these four commands:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.INCBIN "kitten.bin" SKIP 10 READ 8 SWAP FSIZE size_of_kitten FILTER filtermacro
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This example shows how to incbin eight bytes (swapped) after skipping
10 bytes from the beginning of file \fBkitten.bin\fP, and how to get the
size of the file into a definition label \fBsize_of_kitten\fP\&. All the data bytes
are circulated through a filter macro.
.sp
Here\(aqs an example of a filter macro that increments all the bytes by one:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.macro filtermacro    ; the input byte is \e1, the output byte is in "_out"
\&.redefine _out \e1+1
\&.endm
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that the order of the extra commands is important.
.sp
If the file\(aqs not found in the \fB\&.INCDIR\fP directory, WLA tries to find it
in the current working directory. If the \fBINCDIR\fP is specified in the command
line, WLA will first search for the file in that directory. If not found, it
will then proceed as aforementioned.
.sp
This is not a compulsory directive.
.SH .INPUT NAME
.sp
\fB\&.INPUT\fP is much like any Basic\-language input: \fB\&.INPUT\fP asks the user
for a value or string. After \fB\&.INPUT\fP is the variable name used to store
the data.
.sp
\fB\&.INPUT\fP works like \fB\&.REDEFINE\fP, but the user gets to type in the data.
.sp
Here are few examples how to use input:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.PRINTT "The name of the ROM? "
\&.INPUT NAME
\&.NAME NAME

\&...

\&.PRINTT "Give the .DB amount.\en"
\&.INPUT S
\&.PRINTT "Give .DB data one at a time.\en"
\&.REPEAT S
  .INPUT B
  .DB B
\&.ENDR

\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .BACKGROUND "PARALLAX.GB"
.sp
This chooses an existing ROM image (\fBparallax.gb\fP in this case) as a
background data for the project. You can overwrite the data with \fBOVERWRITE\fP
sections only, unless you first clear memory blocks with \fB\&.UNBACKGROUND\fP
after which there\(aqs room for other sections as well.
.sp
Note that \fB\&.BACKGROUND\fP can be used only when compiling an object file.
.sp
\fB\&.BACKGROUND\fP is useful if you wish to patch an existing ROM image with
new code or data.
.sp
This is not a compulsory directive.
.SH .UNBACKGROUND $1000 $1FFF
.sp
After issuing \fB\&.BACKGROUND\fP you might want to free some parts of the
backgrounded ROM image for e.g., \fBFREE\fP sections. With \fB\&.UNBACKGROUND\fP
you can define such regions. In the example a block starting at
\fB$1000\fP and ending at \fB$1FFF\fP was released (both ends included). You can
issue \fB\&.UNBACKGROUND\fP as many times as you wish.
.sp
This is not a compulsory directive.
.SH .FAIL
.sp
Terminates the compiling process.
.sp
This is not a compulsory directive.
.SH .FCLOSE FP_DATABIN
.sp
Closes the filehandle \fBFP_DATABIN\fP\&.
.sp
This is not a compulsory directive.
.SH .FOPEN "DATA.BIN" FP_DATABIN
.sp
Opens the file \fBdata.bin\fP for reading and associates the filehandle with
name \fBFP_DATABIN\fP\&.
.sp
This is not a compulsory directive.
.SH .FREAD FP_DATABIN DATA
.sp
Reads one byte from \fBFP_DATABIN\fP and creates a definition called
\fBDATA\fP to hold it. \fBDATA\fP is an ordinary definition label, so you can
\fB\&.UNDEFINE\fP it.
.sp
Here\(aqs an example on how to use \fB\&.FREAD\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.fopen "data.bin" fp
\&.fsize fp t
\&.repeat t
\&.fread fp d
\&.db d+26
\&.endr
\&.undefine t, d
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .FSIZE FP_DATABIN SIZE
.sp
Creates a definition called \fBSIZE\fP, which holds the size of the file
associated with the filehandle \fBFP_DATABIN\fP\&. \fBSIZE\fP is an ordinary
definition label, so you can \fB\&.UNDEFINE\fP it.
.sp
This is not a compulsory directive.
.SH .MACRO TEST
.sp
Begins a macro called \fBTEST\fP\&.
.sp
You can use \fB\e@\fP inside a macro to e.g., separate a label from the other
macro \fBTEST\fP occurrences. \fB\e@\fP is replaced with an integer number
indicating the amount of times the macro has been called previously so
it is unique to every macro call. \fB\e@\fP can also be used inside strings
inside a macro or just as a plain value. Look at the following examples
for more information.
.sp
You can also type \fB\e!\fP to get the name of the source file currently being
parsed.
.sp
Also, if you want to use macro arguments in e.g., calculation, you can
type \fB\eX\fP where \fBX\fP is the number of the argument. Another way to refer
to the arguments is to use their names given in the definition of the
macro (see the examples for this).
.sp
Remember to use \fB\&.ENDM\fP to finish the macro definition. Note that you
cannot use \fB\&.INCLUDE\fP inside a macro. Note that WLA\(aqs macros are in fact
more like procedures than real macros, because WLA doesn\(aqt substitute
macro calls with macro data. Instead WLA jumps to the macro when it
encounters a macro call at compile time.
.sp
You can call macros from inside a macro. Note that the preprocessor
does not expand the macros. WLA traverses through the code according to
the macro calls.
.sp
Here are some examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.MACRO NOPMONSTER
    .REPT 32         ; gives us 32 NOPs
    NOP
    .ENDR
\&.ENDM

\&.MACRO LOAD_ABCD
    LD A, \e1
    LD B, \e2
    LD C, \e3
    LD D, :\e4        ; load the bank number of \e4 into register D.
    NOPMONSTER       ; note that \e4 must be a label for this to work.
    LD HL, 1<<\e1
\&.INCBIN \e5
\&.ENDM

\&.MACRO QUEEN

QUEEN\e@:
    LD   A, \e1
    LD   B, \e1
    CALL QUEEN\e@

    .DB  "\e@", 0     ; will translate into a zero terminated string
                     ; holding the amount of macro QUEEN calls.
    .DB  "\e\e@", 0    ; will translate into a string containing
                     ; \e@.
    .DB  \e@          ; will translate into a number indicating
                     ; the amount of macro QUEEN calls.

\&.ENDM

\&.MACRO LOAD_ABCD_2 ARGS ONE, TWO, THREE, FOUR, FIVE
    LD A, ONE
    LD B, TWO
    LD C, THREE
    LD D, FOUR
    NOPMONSTER
    LD HL, 1<<ONE
\&.INCBIN FIVE
\&.ENDM

\&.MACRO TEST NARGS 3
    .DB \e1, \e2, \e3
\&.ENDM
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
And here\(aqs how they can be used:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
NOPMONSTER
LOAD_ABCD $10, $20, $30, XYZ, "merman.bin"
QUEEN 123
LOAD_ABCD_2 $10, $20, $30, XYZ, "merman.bin"
TEST 1, 2, 3
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that you must separate the arguments with commas.
.sp
If you want to give names to the macro\(aqs arguments you can do that
by listing them in order after supplying ARGS after the macro\(aqs name.
.sp
Every time a macro is called a definition \fBNARGS\fP is created. It shows
only inside the macro and holds the number of arguments the macro
was called with. So don\(aqt have your own definition called \fBNARGS\fP\&.
Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.MACRO LUPIN
  .IF NARGS != 1
    .FAIL
  .ENDIF

  .PRINTT "Totsan! Ogenki ka?\en"
\&.ENDM
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .ENDM
.sp
Ends a \fB\&.MACRO\fP\&.
.sp
This is not a compulsory directive, but when \fB\&.MACRO\fP is used this one is
required to terminate it.
.SH .SHIFT
.sp
Shifts the macro arguments one down (\fB\e2\fP becomes \fB\e1\fP, \fB\e3\fP \-> \fB\e2\fP,
etc.). \fB\&.SHIFT\fP can thus only be used inside a \fB\&.MACRO\fP\&.
.sp
This is not a compulsory directive.
.SH .FASTROM
.sp
Sets the ROM memory speed bit in \fB$FFD5\fP (\fB\&.HIROM\fP), \fB$7FD5\fP (\fB\&.LOROM\fP)
or \fB$FFD5\fP and \fB$40FFD5\fP (\fB\&.EXHIROM\fP) to indicate that the SNES ROM chips
are 120ns chips.
.sp
This is not a compulsory directive.
.SH .SLOWROM
.sp
Clears the ROM memory speed bit in \fB$FFD5\fP (\fB\&.HIROM\fP), \fB$7FD5\fP (\fB\&.LOROM\fP)
or \fB$FFD5\fP and \fB$40FFD5\fP (\fB\&.EXHIROM\fP) to indicate that the SNES ROM chips
are 200ns chips.
.sp
This is not a compulsory directive.
.SH .SMC
.sp
Forces WLALINK to compute a proper SMC header for the ROM file.
.sp
SMC header is a chunk of 512 bytes. WLALINK touches only its first three
bytes, and sets the rest to zeroes. Here\(aqs what will be inside the first
three bytes:
.TS
center;
|l|l|.
_
T{
Byte
T}	T{
Description
T}
_
T{
\fB0\fP
T}	T{
low byte of 8KB page count.
T}
_
T{
\fB1\fP
T}	T{
high byte of 8KB page count.
T}
_
T{
\fB2\fP
T}	T{
.INDENT 0.0
.IP \(bu 2
Bit \fB7\fP: \fB0\fP
.IP \(bu 2
Bit \fB6\fP: \fB0\fP
.IP \(bu 2
Bit \fB5\fP: \fB0\fP = LoROM, \fB1\fP = HiROM
.IP \(bu 2
Bit \fB4\fP: \fB0\fP = LoROM, \fB1\fP = HiROM
.IP \(bu 2
Bit \fB3\fP and \fB2\fP: SRAM size (\fB00\fP = 256Kb, \fB01\fP = 64Kb,
\fB10\fP = 16Kb, \fB11\fP = 0Kb)
.IP \(bu 2
Bit \fB1\fP: \fB0\fP
.IP \(bu 2
Bit \fB0\fP: \fB0\fP
.UNINDENT
T}
_
.TE
.sp
This is not a compulsory directive.
.SH .HIROM
.sp
With this directive you can define the SNES ROM mode to be HiROM.
Issuing \fB\&.HIROM\fP will override the user\(aqs ROM bank map when
WLALINK computes 24\-bit addresses and bank references. If no
\fB\&.HIROM\fP, \fB\&.LOROM\fP or \fB\&.EXHIROM\fP are given then WLALINK obeys the
banking defined in \fB\&.ROMBANKMAP\fP\&.
.sp
\fB\&.HIROM\fP also sets the ROM mode bit in \fB$FFD5\fP\&.
.sp
This is not a compulsory directive.
.SH .EXHIROM
.sp
With this directive you can define the SNES ROM mode to be ExHiROM.
Issuing \fB\&.EXHIROM\fP will override the user\(aqs ROM bank map when
WLALINK computes 24\-bit addresses and bank references. If no
\fB\&.HIROM\fP, \fB\&.LOROM\fP or \fB\&.EXHIROM\fP are given then WLALINK obeys the
banking defined in \fB\&.ROMBANKMAP\fP\&.
.sp
\fB\&.EXHIROM\fP also sets the ROM mode bit in \fB$40FFD5\fP (mirrored in
\fB$FFD5\fP).
.sp
This is not a compulsory directive.
.SH .LOROM
.sp
With this directive you can define the SNES ROM mode to be LoROM.
Issuing \fB\&.LOROM\fP will override the user\(aqs ROM bank map when
WLALINK computes 24\-bit addresses and bank references. If no
\fB\&.HIROM\fP, \fB\&.LOROM\fP or \fB\&.EXHIROM\fP are given then WLALINK obeys the
banking defined in \fB\&.ROMBANKMAP\fP\&.
.sp
WLA defaults to \fB\&.LOROM\fP\&.
.sp
This is not a compulsory directive.
.SH .BASE $80
.sp
Defines the base value for the bank number (used only in 24\-bit addresses and
when getting a label\(aqs bank number with \fB:\fP). Here are few examples of how
to use \fB\&.BASE\fP (both examples assume the label resides in the first ROM
bank):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.BASE $00
label1:
\&.BASE $80
label2:

  JSL label1   ; if label1 address is $1234, this will assemble into
               ; JSL $001234
  JSL label2   ; label2 is also $1234, but this time the result will be
               ; JSL $801234
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB\&.BASE\fP defaults to \fB$00\fP\&. Note that the address of the label will also
contribute to the bank number (bank number == \fB\&.BASE\fP + ROM bank of the
label).
.sp
On 65816, use \fB\&.LOROM\fP, \fB\&.HIROM\fP or \fB\&.EXHIROM\fP to define the ROM mode.
.sp
This is not a compulsory directive.
.SH .BLOCK "BLOCK1"
.sp
Begins a block (called \fBBlock1\fP in the example). These blocks have only
one function: to display the number of bytes they contain. When you
embed such a block into your code, WLA displays its size when it assembles
the source file.
.sp
Use \fB\&.ENDB\fP to terminate a \fB\&.BLOCK\fP\&. Note that you can nest \fB\&.BLOCK\fP s.
.sp
This is not a compulsory directive.
.SH .ENDB
.sp
Terminates \fB\&.BLOCK\fP\&.
.sp
This is not a compulsory directive, but when \fB\&.BLOCK\fP is used this one is
required to terminate it.
.SH .BANK 0 SLOT 1
.sp
Defines the ROM bank and the slot it is inserted into in the memory. You
can also type the following:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.BANK 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This tells WLA to move into BANK 0 which will be put into the \fBDEFAULTSLOT\fP
of \fB\&.MEMORYMAP\fP\&.
.sp
Every time you use \fB\&.BANK\fP, supply \fB\&.ORG\fP/\fB\&.ORGA\fP as well, just to make
sure WLA calculates addresses correctly.
.sp
This is a compulsory directive.
.SH .SLOT 1
.sp
Changes the currently active memory slot. This directive is meant to be
used with \fBSUPERFREE\fP sections, where only the slot number is constant
when placing the sections.
.sp
This is not a compulsory directive.
.SH .ROMBANKSIZE $4000
.sp
Defines the ROM bank size. Old syntax is \fB\&.BANKSIZE x\fP\&.
.sp
This is a compulsory directive unless \fB\&.ROMBANKMAP\fP is defined.
.SH .ORG $150
.sp
Defines the starting address. The value supplied here is relative to the
ROM bank given with \fB\&.BANK\fP\&.
.sp
When WLA starts to parse a source file, \fB\&.ORG\fP is set to \fB$0\fP, but it\(aqs
always a good idea to explicitly use \fB\&.ORG\fP, for clarity.
.sp
This is a compulsory directive.
.SH .ORGA $150
.sp
Defines the starting address. The value supplied here is absolute and used
directly in address computations. WLA computes the right position in
ROM file. By using \fB\&.ORGA\fP you can instantly see from the source file where
the following code is located in the 16\-bit memory.
.sp
Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.MEMORYMAP
SLOTSIZE $4000
DEFAULTSLOT 0
SLOT 0 $0000
SLOT 1 $4000
\&.ENDME

\&.ROMBANKMAP
BANKSTOTAL 2
BANKSIZE $4000
BANKS 2
\&.ENDRO

\&.BANK 0 SLOT 1
\&.ORGA $4000

MAIN:       JP      MAIN
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here \fBMAIN\fP is at \fB$0000\fP in the ROM file, but the address for label
\fBMAIN\fP is \fB$4000\fP\&. By using \fB\&.ORGA\fP instead of \fB\&.ORG\fP, you can directly
see from the value the address where you want the code to be as \fB\&.ORG\fP is
just an offset to the \fBSLOT\fP\&.
.SH .DS 256, $10
.sp
\fB\&.DS\fP is an alias for \fB\&.DSB\fP\&.
.sp
This is not a compulsory directive.
.SH .DSB 256, $10
.sp
Defines \fB256\fP bytes of \fB$10\fP\&.
.sp
This is not a compulsory directive.
.SH .DSTRUCT WATERDROP INSTANCEOF WATER VALUES
.sp
Defines an instance of struct water, called waterdrop, and fills
it with the given data. Before calling \fB\&.DSTRUCT\fP we must have defined
the structure, and in this example it could be like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.STRUCT water
    name   ds 8
    age    db
    weight dw
\&.ENDST
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
There are two syntaxes for .DSTRUCT; the new and legacy versions. To use
the new syntax, put the keyword "VALUES" at the end of the first line.
The old syntax uses the keyword "DATA" or none at all.
.sp
The new syntax looks like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DSTRUCT waterdrop INSTANCEOF water VALUES
    name:   .db "tingle"
    age:    .db 40
    weight: .dw 120
\&.ENDST
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The fields can be put in any order. Any omitted fields are set to the
\fB\&.EMPTYFILL\fP value (\fB$00\fP by default). Any data\-defining directive
can be used within .DSTRUCT, as long as it does not exceed the size of
the data it is being defined for. The only exception is .DSTRUCT itself,
which cannot be nested.
.sp
The old syntax looks like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DSTRUCT waterdrop INSTANCEOF water DATA "tingle", 40, 120
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fBDATA\fP and \fBINSTANCEOF\fP keywords are optional. This will assign
data for each field of the struct in the order they were defined.
.sp
In either example you would get the following labels:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
waterdrop
waterdrop.name
waterdrop.age
waterdrop.weight
_sizeof_waterdrop        = 11
_sizeof_waterdrop.name   = 8
_sizeof_waterdrop.age    = 1
_sizeof_waterdrop.weight = 2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The legacy syntax does not support unions; it will give an error if you
attempt to define data for a union.
.sp
For the new syntax, nested structs are supported like so (assume the
\fBwater\fP struct is also defined:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.STRUCT drop_pair
    waterdrops: instanceof water 2
\&.ENDST

\&.DSTRUCT drops INSTANCEOF drop_pair VALUES
    waterdrops.1:        .db "qwertyui" 40
                         .dw 120
    waterdrops.2.name:   .db "tingle"
    waterdrops.2.age:    .db 40
    waterdrops.2.weight: .dw 12
\&.ENDST
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In this case, the properties of \fBwaterdrops.1\fP were defined
implicitly; 8 bytes for the name, followed by a byte for the age,
followed by a word for the weight. The values for \fBwaterdrops.2\fP were
defined in a more clear way.
.sp
In this case, \fBwaterdrops\fP and \fBwaterdrops.1\fP are equivalent.
\fBwaterdrops.1.name\fP is different, even though its address is the same,
because it has a size of 8. If you attempted to do this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DSTRUCT drops INSTANCEOF drop_pair VALUES
    waterdrops.1.name:   .db "qwertyui" 40
                         .dw 120
\&.ENDST
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It would fail, because only the 8 name bytes are available to be defined
in this context, as opposed to the 11 bytes for the entire
\fBwaterdrops.1\fP structure.
.sp
Named unions can be assigned to in a similar way, by writing its full
name with a \fB\&.\fP separating the union name and the field name.
.sp
The struct can be defined namelessly, in which case no labels will be
generated, like so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DSTRUCT INSTANCEOF drop_pair VALUES
    ...
\&.ENDST
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .DSW 128, 20
.sp
Defines \fB128\fP words (two bytes) of \fB20\fP\&.
.sp
This is not a compulsory directive.
.SH .DSL 16, $102030
.sp
Defines \fB16\fP long words (three bytes) of \fB$102030\fP\&. Works only
on wla\-65816.
.sp
This is not a compulsory directive.
.SH .DB 100, $30, %1000, "HELLO WORLD!"
.sp
Defines bytes.
.sp
This is not a compulsory directive.
.SH .BYT 100, $30, %1000, "HELLO WORLD!"
.sp
\fB\&.BYT\fP is an alias for \fB\&.DB\fP\&.
.sp
This is not a compulsory directive.
.SH .DBM FILTERMACRO 1, 2, "ENCRYPT ME"
.sp
Defines bytes using a filter macro. All the data is passed to \fBfiltermacro\fP
in the first argument, one byte at a time, and the byte that actually gets
defined is the value of definition \fB_OUT\fP (\fB_out\fP works as well). The
second macro argument holds the offset from the beginning (the first byte) in
bytes (the series being \fB0\fP, \fB1\fP, \fB2\fP, \fB3\fP, ...).
.sp
Here\(aqs an example of a filter macro that increments all the bytes by one:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.macro increment
\&.redefine _out \e1+1
\&.endm
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .SYM SAUSAGE
.sp
WLA treats symbols (\fBSAUSAGE\fP in this example) like labels, but they
only appear in the symbol files WLALINK outputs. Useful for finding out
the location where WLALINK puts data.
.sp
This is not a compulsory directive.
.SH .SYMBOL SAUSAGE
.sp
\fB\&.SYMBOL\fP is an alias for \fB\&.SYM\fP\&.
.sp
This is not a compulsory directive.
.SH .BR
.sp
Inserts a breakpoint that behaves like a \fB\&.SYM\fP without a name. Breakpoints
can only be seen in WLALINK\(aqs symbol file.
.sp
This is not a compulsory directive.
.SH .BREAKPOINT
.sp
\fB\&.BREAKPOINT\fP is an alias for \fB\&.BR\fP\&.
.sp
This is not a compulsory directive.
.SH .ASCIITABLE
.sp
\fB\&.ASCIITABLE\fP\(aqs only purpose is to provide character mapping for \fB\&.ASC\fP\&.
Take a look at the example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ASCIITABLE
MAP "A" TO "Z" = 0
MAP "!" = 90
\&.ENDA
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here we set such a mapping that character \fBA\fP is equal to \fB0\fP, \fBB\fP is
equal to \fB1\fP, \fBC\fP is equal to \fB2\fP, and so on, and \fB!\fP is equal
to \fB90\fP\&.
.sp
After you\(aqve given the \fB\&.ASCIITABLE\fP, use \fB\&.ASC\fP to define bytes using
this mapping (\fB\&.ASC\fP is an alias for \fB\&.DB\fP, but with \fB\&.ASCIITABLE\fP
mapping). For example, \fB\&.ASC "ABZ"\fP would define bytes \fB0\fP, \fB1\fP and
\fB25\fP in our previous example.
.sp
Note that the following works as well:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ASCIITABLE
MAP \(aqA\(aq TO \(aqZ\(aq = 0
MAP 65 = 90          ; 65 is the decimal for ASCII \(aqA\(aq
\&.ENDA
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Also note that the characters that are not given any mapping in
\fB\&.ASCIITABLE\fP map to themselves (i.e., \fB2\fP maps to \fB2\fP in our previous
example, etc.).
.sp
This is not a compulsory directive.
.SH .ENDA
.sp
Ends the ASCII table.
.sp
This is not a compulsory directive, but when \fB\&.ASCIITABLE\fP or \fB\&.ASCTABLE\fP
are used this one is required to terminate them.
.SH .ASCTABLE
.sp
\fB\&.ASCTABLE\fP is an alias for \fB\&.ASCIITABLE\fP\&.
.sp
This is not a compulsory directive.
.SH .ASC "HELLO WORLD!"
.sp
\fB\&.ASC\fP is an alias for \fB\&.DB\fP, but if you use \fB\&.ASC\fP it will remap
the characters using the mapping given via \fB\&.ASCIITABLE\fP\&.
.sp
This is not a compulsory directive.
.SH .DW 16000, 10, 255
.sp
Defines words (two bytes each). \fB\&.DW\fP takes only numbers, labels and
characters as input, not strings.
.sp
This is not a compulsory directive.
.SH .WORD 16000, 10, 255
.sp
\fB\&.WORD\fP is an alias for \fB\&.DW\fP\&.
.sp
This is not a compulsory directive.
.SH .ADDR 16000, MAIN, 255
.sp
\fB\&.ADDR\fP is an alias for \fB\&.DW\fP\&.
.sp
This is not a compulsory directive.
.SH .DL $102030, $405060
.sp
Defines long words (three bytes each). \fB\&.DL\fP takes only numbers, labels and
characters as input, not strings. Works only on wla\-65816.
.sp
This is not a compulsory directive.
.SH .LONG $102030, $405060
.sp
\fB\&.LONG\fP is an alias for \fB\&.DL\fP\&. Works only on wla\-65816.
.sp
This is not a compulsory directive.
.SH .FARADDR MAIN, IRQ_1
.sp
\fB\&.FARADDR\fP is an alias for \fB\&.DL\fP\&. Works only on wla\-65816.
.sp
This is not a compulsory directive.
.SH .DWM FILTERMACRO 1, 2, 3
.sp
Defines 16\-bit words using a filter macro. All the data is passed to
\fBfiltermacro\fP in the first argument, one word at a time, and the word that
actually gets defined is the value of definition \fB_OUT\fP (\fB_out\fP works as
well). The second macro argument holds the offset from the beginning (the
first word) in bytes (the series being \fB0\fP, \fB2\fP, \fB4\fP, \fB6\fP, ...).
.sp
Here\(aqs an example of a filter macro that increments all the words by one:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.macro increment
\&.redefine _out \e1+1
\&.endm
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .DEFINE IF $FF0F
.sp
Assigns a number or a string to a definition label.
.sp
By default all defines are local to the file where they are
presented. If you want to make the definition visible to all the
files in the project, use \fB\&.EXPORT\fP or add EXPORT to the end of .DEFINE:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE ID_0 0 EXPORT
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
WARNING: Please declare your definition lexically before using it as otherwise
the assembler might make incorrect assumptions about its value and size and
choose e.g. wrong opcodes and generate binary that doesn\(aqt run properly.
.sp
Here are some examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE X 1000
\&.DEFINE FILE "level01.bin"
\&.DEFINE TXT1 "hello and welcome", 1, "to a new world...", 0
\&.DEFINE BYTES 1, 2, 3, 4, 5
\&.DEFINE COMPUTATION X+1
\&.DEFINE DEFAULTV
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
All definitions with multiple values are marked as data strings,
and \fB\&.DB\fP is about the only place where you can later on use them.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE BYTES 1, 2, 3, 4, 5
\&.DB 0, BYTES, 6
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
is the same as
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DB 0, 1, 2, 3, 4, 5, 6
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you omit the definition value (in our example \fBDEFAULTV\fP), WLA
will default to \fB0\fP\&.
.sp
Note that you must do your definition before you use it, otherwise
WLA will use the final value of the definition. Here\(aqs an example
of this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE AAA 10
\&.DB AAA            ; will be 10.
\&.REDEFINE AAA 11
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
but
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DB AAA            ; will be 11.
\&.DEFINE AAA 10
\&.REDEFINE AAA 11
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can also create definitions on the command line. Here\(aqs an
example of this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wla\-gb \-vl \-DMOON \-DNAME=john \-DPRICE=100 \-DADDRESS=$100 math.s
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBMOON\fP\(aqs value will be \fB0\fP, \fBNAME\fP is a string definition with value
\fBjohn\fP, \fBPRICE\fP\(aqs value will be \fB100\fP, and \fBADDRESS\fP\(aqs value will be
\fB$100\fP\&.
.sp
Note that
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE AAA = 10   ; the same as ".DEFINE AAA 10".
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
works as well.
.sp
This is not a compulsory directive.
.SH .DEF IF $FF0F
.sp
\fB\&.DEF\fP is an alias for \fB\&.DEFINE\fP\&.
.sp
This is not a compulsory directive.
.SH .EQU IF $FF0F
.sp
\fB\&.EQU\fP is an alias for \fB\&.DEFINE\fP\&.
.sp
This is not a compulsory directive.
.SH .REDEFINE IF $0F
.sp
Assigns a new value or a string to an old definition. If the
definition doesn\(aqt exist, \fB\&.REDEFINE\fP performs \fB\&.DEFINE\fP\(aqs work.
.sp
When used with \fB\&.REPT\fP \fBREDEFINE\fP helps creating tables:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE CNT 0

\&.REPT 256
\&.DB CNT
\&.REDEFINE CNT CNT+1
\&.ENDR
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .REDEF IF $0F
.sp
\fB\&.REDEF\fP is an alias for \fB\&.REDEFINE\fP\&.
.sp
This is not a compulsory directive.
.SH .IF DEBUG == 2
.sp
If the condition is fulfilled the following piece of code is
acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise
it is skipped. Operands must be immediate values or strings.
.sp
The following operators are supported:
.TS
center;
|l|l|.
_
T{
\fB<\fP
T}	T{
less than
T}
_
T{
\fB<=\fP
T}	T{
less or equal to
T}
_
T{
\fB>\fP
T}	T{
greater than
T}
_
T{
\fB>=\fP
T}	T{
greater or equal to
T}
_
T{
\fB==\fP
T}	T{
equals to
T}
_
T{
\fB!=\fP
T}	T{
doesn\(aqt equal to
T}
_
.TE
.sp
All \fBIF\fP directives (yes, including \fB\&.IFDEF\fP, \fB\&.IFNDEF\fP, etc) can be
nested. They can also be used within \fBENUM\fP s, \fBRAMSECTION\fP s,
\fBSTRUCT\fP s, \fBROMBANKMAP\fP s, and most other directives that occupy multiple
lines.
.sp
This is not a compulsory directive.
.SH .IFDEF IF
.sp
If \fBIF\fP is defined, then the following piece of code is acknowledged
until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise it is skipped.
.sp
This is not a compulsory directive.
.SH .IFEXISTS "MAIN.S"
.sp
If \fBmain.s\fP file can be found, then the following piece of code is
acknowledged until \fB\&.ENDIF\fP/\fB\&.LESE\fP occurs in the text, otherwise it is
skipped.
.sp
By writing the following few lines you can include a file if it exists
without breaking the compiling loop if it doesn\(aqt exist.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.IFEXISTS FILE
\&.INCLUDE FILE
\&.ENDIF
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .UNDEFINE DEBUG
.sp
Removes the supplied definition label from system. If there is no
such label as given no error is displayed as the result would be the
same.
.sp
You can undefine as many definitions as you wish with one \fB\&.UNDEFINE\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.UNDEFINE NUMBER, NAME, ADDRESS, COUNTRY
\&.UNDEFINE NAME, AGE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .UNDEF DEBUG
.sp
\fB\&.UNDEF\fP is an alias for \fB\&.UNDEFINE\fP\&.
.sp
This is not a compulsory directive.
.SH .IFNDEF IF
.sp
If \fBIF\fP is not defined, then the following piece of code is acknowledged
until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise it is skipped.
.sp
This is not a compulsory directive.
.SH .IFDEFM \2
.sp
If the specified argument is defined (argument number two, in the example),
then the following piece of code is acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP
occurs in the macro, otherwise it is skipped.
.sp
This is not a compulsory directive. \fB\&.IFDEFM\fP works only inside a macro.
.SH .IFNDEFM \2
.sp
If the specified argument is not defined, then the following piece of
code is acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the macro, otherwise
it is skipped.
.sp
This is not a compulsory directive. \fB\&.IFNDEFM\fP works only inside a macro.
.SH .IFEQ DEBUG 2
.sp
If the value of \fBDEBUG\fP equals to \fB2\fP, then the following piece of code is
acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise it is
skipped. Both arguments can be computations, defines or immediate values.
.sp
This is not a compulsory directive.
.SH .IFNEQ DEBUG 2
.sp
If the value of \fBDEBUG\fP doesn\(aqt equal to \fB2\fP, then the following piece of
code is acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise
it is skipped. Both arguments can be computations, defines or immediate values.
.sp
This is not a compulsory directive.
.SH .IFLE DEBUG 2
.sp
If the value of \fBDEBUG\fP is less than \fB2\fP, then the following piece of code
is acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise it is
skipped. Both arguments can be computations, defines or immediate values.
.sp
This is not a compulsory directive.
.SH .IFLEEQ DEBUG 2
.sp
If the value of \fBDEBUG\fP is less or equal to \fB2\fP, then the following piece of
code is acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise
it is skipped. Both arguments can be computations, defines or immediate values.
.sp
This is not a compulsory directive.
.SH .IFGR DEBUG 2
.sp
If the value of \fBDEBUG\fP is greater than \fB2\fP, then the following piece of
code is acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text, otherwise
it is skipped. Both arguments can be computations, defines or immediate values.
.sp
This is not a compulsory directive.
.SH .IFGREQ DEBUG 2
.sp
If the value of \fBDEBUG\fP is greater or equal to \fB2\fP, then the following
pieceof code is acknowledged until \fB\&.ENDIF\fP/\fB\&.ELSE\fP occurs in the text,
otherwise it is skipped. Both arguments can be computations, defines or
immediate values.
.sp
This is not a compulsory directive.
.SH .ELSE
.sp
If the previous \fB\&.IFxxx\fP failed then the following text until
\fB\&.ENDIF\fP is acknowledged.
.sp
This is not a compulsory directive.
.SH .ENDIF
.sp
This terminates any \fB\&.IFxxx\fP directive.
.sp
This is not a compulsory directive, but if you use any \fB\&.IFxxx\fP then
you need also to apply this.
.SH .REPEAT 6
.sp
Repeats the text enclosed between \fB\&.REPEAT x\fP and \fB\&.ENDR\fP \fBx\fP times
(\fB6\fP in this example). You can use \fB\&.REPEAT\fP s inside \fB\&.REPEAT\fP s.
\fBx\fP must be bigger or equal than \fB0\fP\&.
.sp
It\(aqs also possible to have the repeat counter/index in a definition:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.REPEAT 6 INDEX COUNT
\&.DB COUNT
\&.ENDR
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This would define bytes \fB0\fP, \fB1\fP, \fB2\fP, \fB3\fP, \fB4\fP and \fB5\fP\&.
.sp
This is not a compulsory directive.
.SH .REPT 6
.sp
\fB\&.REPT\fP is an alias for \fB\&.REPEAT\fP\&.
.sp
This is not a compulsory directive.
.SH .ENDR
.sp
Ends the repetition.
.sp
This is not a compulsory directive, but when \fB\&.REPEAT\fP is used this one is
required to terminate it.
.SH .ENUM $C000
.sp
Starts enumeration from \fB$C000\fP\&. Very useful for defining variables.
.sp
To start a descending enumeration, put \fBDESC\fP after the starting
value. WLA defaults to \fBASC\fP (ascending enumeration).
.sp
You can also add \fBEXPORT\fP after these if you want to export all
the generated definitions automatically.
.sp
Here\(aqs an example of \fB\&.ENUM\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&...
\&.STRUCT mon                ; check out the documentation on
name ds 2                  ; .STRUCT
age  db
\&.ENDST

\&.ENUM $A000
_scroll_x DB               ; db  \- define byte (byt and byte work also)
_scroll_y DB
player_x: DW               ; dw  \- define word (word works also)
player_y: DW
map_01:   DS  16           ; ds  \- define size (bytes)
map_02    DSB 16           ; dsb \- define size (bytes)
map_03    DSW  8           ; dsw \- define size (words)
monster   INSTANCEOF mon 3 ; three instances of structure mon
dragon    INSTANCEOF mon   ; one mon
\&.ENDE
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Previous example transforms into following definitions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE _scroll_x      $A000
\&.DEFINE _scroll_y      $A001
\&.DEFINE player_x       $A002
\&.DEFINE player_y       $A004
\&.DEFINE map_01         $A006
\&.DEFINE map_02         $A016
\&.DEFINE map_03         $A026
\&.DEFINE monster        $A036
\&.DEFINE monster.1      $A036
\&.DEFINE monster.1.name $A036
\&.DEFINE monster.1.age  $A038
\&.DEFINE monster.2      $A039
\&.DEFINE monster.2.name $A039
\&.DEFINE monster.2.age  $A03B
\&.DEFINE monster.3      $A03C
\&.DEFINE monster.3.name $A03C
\&.DEFINE monster.3.age  $A03E
\&.DEFINE dragon         $A03F
\&.DEFINE dragon.name    $A03F
\&.DEFINE dragon.age     $A041
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBDB\fP, \fBDW\fP, \fBDS\fP, \fBDSB\fP, \fBDSW\fP and \fBINSTANCEOF\fP can also be in
lowercase. You can also use a dotted version of the symbols, but it doesn\(aqt
advance the memory address. Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ENUM $C000 DESC EXPORT
bigapple_h db
bigapple_l db
bigapple:  .dw
\&.ENDE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
And this is what is generated:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE bigapple_h $BFFF
\&.DEFINE bigapple_l $BFFE
\&.DEFINE bigapple   $BFFE
\&.EXPORT bigapple, bigapple_l, bigapple_h
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This way you can generate a 16\-bit variable address along with pointers
to its parts.
.sp
Note that you can also use \fBDL\fP (define long word, a 24\-bit value) and
\fBDSL\fP (define size, long words) when running wla\-65816.
.sp
If you want more flexible variable positioning, take a look at
\fB\&.RAMSECTION\fP s.
.sp
This is not a compulsory directive.
.SH .ENDE
.sp
Ends the enumeration.
.sp
This is not a compulsory directive, but when \fB\&.ENUM\fP is used this one is
required to terminate it.
.SH .STRUCT ENEMY_OBJECT
.sp
Begins the definition of a structure. These structures can be placed
inside \fBRAMSECTION\fP s and \fBENUM\fP s. Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.STRUCT enemy_object
id      dw             ; the insides of a .STRUCT are 1:1 like in .ENUM
x       db             ; except that no structs inside structs are
y       db             ; allowed.
data    ds  10
info    dsb 16
stats   dsw  4
\&.ENDST
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This also creates a definition \fB_sizeof_[struct name]\fP, in our example
this would be \fB_sizeof_enemy_object\fP, and the value of this definition
is the size of the object, in bytes (2+1+1+10+16+4*2 = 38 in the example).
.sp
You\(aqll get the following definitions as well:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
enemy_object.id    (== 0)
enemy_object.x     (== 2)
enemy_object.y     (== 3)
enemy_object.data  (== 4)
enemy_object.info  (== 14)
enemy_object.stats (== 30)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After defining a \fB\&.STRUCT\fP you can create an instance of it in a
\fB\&.RAMSECTION\fP / \fB\&.ENUM\fP by typing
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<instance name> INSTANCEOF <struct name> [optional, the number of structures]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.RAMSECTION "enemies" BANK 4 SLOT 4
enemies   INSTANCEOF enemy_object 4
enemyman  INSTANCEOF enemy_object
enemyboss INSTANCEOF enemy_object
\&.ENDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This will create labels like \fBenemies\fP, \fBenemies.id\fP, \fBenemies.x\fP,
\fBenemies.y\fP and so on. Label \fBenemies\fP is followed by four \fBenemy_object\fP
structures, and only the first one is labeled. After there four come
\fBenemyman\fP and \fBenemyboss\fP instances.
.sp
Take a look at the documentation on \fB\&.RAMSECTION\fP & \fB\&.ENUM\fP, they have more
examples of how you can use \fB\&.STRUCT\fP s.
.sp
\fBA WORD OF WARNING\fP: Don\(aqt use labels \fBb\fP, \fBB\fP, \fBw\fP and \fBW\fP inside a
structure as e.g., WLA sees \fBenemy.b\fP as a byte sized reference to enemy. All
other labels should be safe.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
lda enemy1.b  ; load a byte from zeropage address enemy1 or from the address
              ; of enemy1.b??? i can\(aqt tell you, and WLA can\(aqt tell you...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .ENDST
.sp
Ends the structure definition.
.sp
This is not a compulsory directive, but when \fB\&.STRUCT\fP is used this one is
required to terminate it.
.SH .MEMORYMAP
.sp
Begins the memory map definition. Using \fB\&.MEMORYMAP\fP you must first
describe the target system\(aqs memory architecture to WLA before it
can start to compile the code. \fB\&.MEMORYMAP\fP gives you the freedom to
use WLA to compile data for numerous different real
Z80/6502/65C02/6510/6800/6801/6809/8008/8080/65816/HUC6280/SPC\-700
based systems.
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.MEMORYMAP
DEFAULTSLOT 0
SLOTSIZE $4000
SLOT 0 $0000
SLOT 1 $4000
\&.ENDME

\&.MEMORYMAP
DEFAULTSLOT 0
SLOT 0 $0000 $4000
SLOT 1 $4000 $4000
\&.ENDME

\&.MEMORYMAP
DEFAULTSLOT 0
SLOT 0 START $0000 SIZE $4000
SLOT 1 START $4000 SIZE $4000
\&.ENDME

\&.MEMORYMAP
DEFAULTSLOT 1
SLOTSIZE $6000
SLOT 0 $0000
SLOTSIZE $2000
SLOT 1 $6000
SLOT 2 $8000
\&.ENDME
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here\(aqs a real life example from Adam Klotblixt. It should be interesting
for all the ZX81 coders:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&...

\&.MEMORYMAP
DEFAULTSLOT 1
SLOTSIZE $2000
SLOT 0 $0000
SLOTSIZE $6000
SLOT 1 $2000
\&.ENDME

\&.ROMBANKMAP
BANKSTOTAL 2
BANKSIZE $2000
BANKS 1
BANKSIZE $6000
BANKS 1
\&.ENDRO

\&.BANK 1 SLOT 1
\&.ORGA $2000

\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBSLOTSIZE\fP defines the size of the following slots, unless you explicitly
specify the size of the slot, like in the second and third examples. You
can redefine \fBSLOTSIZE\fP as many times as you wish.
.sp
\fBDEFAULTSLOT\fP describes the default slot for banks which aren\(aqt explicitly
inserted anywhere. Check \fB\&.BANK\fP definition for more information.
.sp
\fBSLOT\fP defines a slot and its starting address. \fBSLOT\fP numbering starts at
\fB0\fP and ends to \fB255\fP so you have 256 slots at your disposal.
.sp
This is a compulsory directive, and make sure all the object files share
the same \fB\&.MEMORYMAP\fP or you can\(aqt link them together.
.sp
Note that both \fBSTART\fP and \fBSIZE\fP are optional!
.SH .ENDME
.sp
Terminates \fB\&.MEMORYMAP\fP\&.
.sp
This is not a compulsory directive, but when \fB\&.MEMORYMAP\fP is used this one
is required to terminate it.
.SH .ROMBANKMAP
.sp
Begins the ROM bank map definition. You can use this directive to
describe the project\(aqs ROM banks. Use \fB\&.ROMBANKMAP\fP when not all the
ROM banks are of equal size. Note that you can use \fB\&.ROMBANKSIZE\fP and
\fB\&.ROMBANKS\fP instead of \fB\&.ROMBANKMAP\fP, but that\(aqs only when the ROM banks
are equal in size. Some systems based on a real Z80 chip,
6502/65C02/6510/65816/6800/6801/6809/8008/8080/HUC6280/SPC\-700 CPUs and
Pocket Voice cartridges for Game Boy require the usage of this directive.
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ROMBANKMAP
BANKSTOTAL 16
BANKSIZE $4000
BANKS 16
\&.ENDRO

\&.ROMBANKMAP
BANKSTOTAL 510
BANKSIZE $6000
BANKS 1
BANKSIZE $2000
BANKS 509
\&.ENDRO
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The first one describes an ordinary ROM image of 16 equal sized
banks. The second one defines a 4MB Pocket Voice ROM image.
In the PV ROM image the first bank is \fB$6000\fP bytes and the remaining
\fB509\fP banks are smaller ones, \fB$2000\fP bytes each.
.sp
\fBBANKSTOTAL\fP tells the total amount of ROM banks. It must be
defined prior to anything else.
.sp
\fBBANKSIZE\fP tells the size of the following ROM banks. You can
supply WLA with \fBBANKSIZE\fP as many times as you wish.
.sp
\fBBANKS\fP tells the amount of banks that follow and that are of
the size \fBBANKSIZE\fP which has been previously defined.
.sp
This is not a compulsory directive when \fB\&.ROMBANKSIZE\fP and
\fB\&.ROMBANKS\fP are defined.
.sp
You can redefine \fB\&.ROMBANKMAP\fP as many times as you wish as long as
the old and the new ROM bank maps match as much as possible. This
way you can enlarge the size of the project on the fly.
.SH .ENDRO
.sp
Ends the rom bank map.
.sp
This is not a compulsory directive, but when \fB\&.ROMBANKMAP\fP is used this
one is required to terminate it.
.SH .SEED 123
.sp
Seeds the random number generator.
.sp
This is not a compulsory directive. The random number generator is
initially seeded with the output of \fBtime()\fP, which is, according to
the manual, \fIthe time since the Epoch (00:00:00 UTC, January 1, 1970),
measured in seconds\fP\&. So if you don\(aqt \fB\&.SEED\fP the random number generator
yourself with a constant value, \fB\&.DBRND\fP and \fB\&.DWRND\fP give you different
values every time you run WLA.
.sp
In WLA DX 9.4a and before we used the stdlib\(aqs \fBsrand()\fP and \fBrand()\fP
functions making the output differ on different platforms. Since v9.4 WLA DX
contains its own Mersenne Twister pseudo random number generator.
.SH .SECTION "INIT" FORCE
.sp
Section is a continuous area of data which is placed into the output
file according to the section type and \fB\&.BANK\fP and \fB\&.ORG\fP directive
values.
.sp
The example begins a section called \fBInit\fP\&. Before a section can be
declared, \fB\&.BANK\fP and \fB\&.ORG\fP must be used unless WLA is in library file
output mode. Library file\(aqs sections must all be \fBFREE\fP ones. \fB\&.BANK\fP
tells the bank number where this section will be later relocated into. \fB\&.ORG\fP
tells the offset for the relocation from the beginning of \fB\&.BANK\fP\&.
.sp
You can put sections inside a namespace. For instance, if you put a section
into a namespace called \fBbank0\fP, then labels in that section can be
accessed with \fBbank0.label\fP\&. This is not necessary inside the section
itself. The namespace directive should immediately follow the name.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SECTION "Init" NAMESPACE "bank0"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can give the size of the section, if you wish to force the section
to some specific size, the following way:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SECTION "Init" SIZE 100 FREE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It\(aqs possible to force WLALINK to align the \fBFREE\fP, \fBSEMIFREE\fP and
\fBSUPERFREE\fP sections by giving the alignment as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SECTION "Init" SIZE 100 ALIGN 4 FREE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
And if you want that WLA returns the \fBORG\fP to what it was before issuing
the section, put \fBRETURNORG\fP at the end of the parameter list:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SECTION "Init" SIZE 100 ALIGN 4 FREE RETURNORG
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
By default WLA advances the \fBORG\fP, so, for example, if your \fBORG\fP was
\fB$0\fP before a section of 16 bytes, then the \fBORG\fP will be \fB16\fP after the
section.
.sp
Note also that if your section name begins with double underlines (e.g.,
\fB__UNIQUE_SECTION!!!\fP) the section will be unique in the sense that
when WLALINK recieves files containing sections which share the same
name, WLALINK will save only the first of them for further processing,
all others are deleted from memory with corresponding labels, references
and calculations.
.sp
If a section name begins with an exclamation mark (\fB!\fP) it tells
WLALINK to not to drop it, even if you use WLALINK\(aqs ability to discard
all unreferenced sections and there are no references to the section.
.sp
\fBFORCE\fP after the name of the section tells WLA that the section \fImust\fP be
inserted so it starts at \fB\&.ORG\fP\&. \fBFORCE\fP can be replaced with \fBFREE\fP
which means that the section can be inserted somewhere in the defined bank,
where there is room. You can also use \fBOVERWRITE\fP to insert the section into
the memory regardless of data collisions. Using \fBOVERWRITE\fP you can easily
patch an existing ROM image just by \fB\&.BACKGROUND\fP\(aqing the ROM image and
inserting \fBOVERWRITE\fP sections into it. \fBSEMIFREE\fP sections are also
possible and they behave much like \fBFREE\fP sections. The only difference is
that they are positioned somewhere in the bank starting from \fB\&.ORG\fP\&.
\fBSEMISUBFREE\fP sections on the other hand are positioned somewhere in the bank
starting from \fB$0\fP and ending to \fB\&.ORG\fP\&.
.sp
\fBSUPERFREE\fP sections are also available, and they will be positioned into
the first suitable place inside the first suitable bank (candidates for these
suitable banks have the same size with the slot of the section, no other banks
are considered). You can also leave away the type specifier as the default type
for the section is \fBFREE\fP\&.
.sp
You can name the sections as you wish, but there is one special name. A section
called \fBBANKHEADER\fP is placed in the front of the bank where it is defined.
These sections contain data that is not in the memory map of the machine, so
you can\(aqt refer to the data of a \fBBANKHEADER\fP section, but you can write
references to outside. So no labels inside \fBBANKHEADER\fP sections. These
special sections are useful when writing e.g., MSX programs. Note that library
files don\(aqt take \fBBANKHEADER\fP sections.
.sp
Here\(aqs an example of a \fBBANKHEADER\fP section:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.BANK 0
\&.ORG 0
\&.SECTION "BANKHEADER"
    .DW MAIN
    .DW VBI
\&.ENDS

\&.SECTION "Program"
MAIN: CALL MONTY_ON_THE_RUN
VBI:  PUSH HL
      ...
      POP HL
      RETI
\&.ENDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here\(aqs an example of an ordinary section:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.BANK 0
\&.ORG $150
\&.SECTION "Init" FREE PRIORITY 1000
        DI
        LD  SP, $FFFE
        SUB A
        LD  ($FF00+R_IE), A
\&.ENDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This tells WLA that a \fBFREE\fP section called \fBInit\fP must be located
somewhere in bank \fB0\fP and it has a sorting \fBPRIORITY\fP of 1000. If you replace
\fBFREE\fP with \fBSEMIFREE\fP the section will be inserted somewhere in the bank \fB0\fP,
but not in the \fB$0\fP \- \fB$14F\fP area. If you replace \fBFREE\fP with \fBSUPERFREE\fP
the section will be inserted somewhere in any bank with the same size as bank \fB0\fP\&.
.sp
Here\(aqs the order in which WLA writes the sections:
.INDENT 0.0
.IP 1. 3
\fBFORCE\fP
.IP 2. 3
\fBSEMISUBFREE\fP
.IP 3. 3
\fBSEMIFREE\fP & \fBFREE\fP
.IP 4. 3
\fBSUPERFREE\fP
.IP 5. 3
\fBOVERWRITE\fP
.UNINDENT
.sp
Before the sections are inserted into the output file, they are sorted by
priorities, so that the section with the highest priority is processed first.
If priorities are the same, then the size of the section matters, and bigger
sections are processed before smaller ones. The default \fBPRIORITY\fP, when not
explicitly given, is 0.
.sp
You can also create a RAM section. For more information about them, please
read the \fB\&.RAMSECTION\fP directive explanation.
.sp
It is also possible to merge two or more sections using \fBAPPENDTO\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SECTION "Base"
\&.DB 0
\&.ENDS

\&.SECTION "AppendToBase" FREE RETURNORG APPENDTO "Base"
\&.DB 1
\&.ENDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .RAMSECTION "VARS" BANK 0 SLOT 1 ALIGN 4
.sp
\fBRAMSECTION\fP s accept only variable labels and variable sizes, and the
syntax to define these is identical to \fB\&.ENUM\fP (all the syntax rules that
apply to \fB\&.ENUM\fP apply also to \fB\&.RAMSECTION\fP). Additionally you can embed
structures (\fB\&.STRUCT\fP) into a \fBRAMSECTION\fP\&. Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.RAMSECTION "Some of my variables" BANK 0 SLOT 1 PRIORITY 100
vbi_counter:   db
player_lives:  db
\&.ENDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBRAMSECTION\fP s behave like \fBFREE\fP sections, but instead of filling any banks
RAM sections will occupy RAM banks inside slots. You can fill different slots
with different variable labels. It\(aqs recommend that you create separate
slots for holding variables (as ROM and RAM don\(aqt usually overlap).
.sp
Keyword \fBPRIORITY\fP means just the same as \fBPRIORITY\fP of a \fB\&.SECTION\fP,
it is used to prioritize some sections when placing them in the output ROM/PRG.
The \fBRAMSECTION\fP s with higher \fBPRIORITY\fP are placed first in the output,
and if the priorities match, then bigger \fBRAMSECTION\fP s are placed first.
.sp
NOTE! Currently WLA\-DX assumes that there are 256 RAM banks available for
each slot in the memory map. There is no other way to limit this number at the
moment than manually keep the \fBBANK\fP number inside real limits.
.sp
Anyway, here\(aqs another example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.MEMORYMAP
SLOTSIZE $4000
DEFAULTSLOT 0
SLOT 0 $0000   ; ROM slot 0.
SLOT 1 $4000   ; ROM slot 1.
SLOT 2 $A000   ; variable RAM is here!
\&.ENDME

\&.STRUCT game_object
x DB
y DB
\&.ENDST

\&.RAMSECTION "vars 1" BANK 0 SLOT 2
moomin1   DW
phantom   DB
nyanko    DB
enemy     INSTANCEOF game_object
\&.ENDS

\&.RAMSECTION "vars 2" BANK 1 SLOT 2
moomin2   DW
\&.ENDS

\&.RAMSECTION "vars 3" BANK 1 SLOT 2
moomin3_all .DSB 3
moomin3_a    DB
moomin3_b    DB
moomin3_c    DB
\&.ENDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If no other RAM sections are used, then this is what you will get:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE moomin1     $A000
\&.DEFINE phantom     $A002
\&.DEFINE nyanko      $A003
\&.DEFINE enemy       $A004
\&.DEFINE enemy.x     $A004
\&.DEFINE enemy.y     $A005
\&.DEFINE moomin2     $A000
\&.DEFINE moomin3_all $A002
\&.DEFINE moomin3_a   $A002
\&.DEFINE moomin3_b   $A003
\&.DEFINE moomin3_c   $A004
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBBANK\fP in \fB\&.RAMSECTION\fP is optional so you can leave it away if you
don\(aqt switch RAM banks, or the target doesn\(aqt have them (defaults to 0).
.sp
NOTE! The generated _sizeof_ labels for \fB\&.RAMSECTION\fP "vars 3" will be:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
_sizeof_moomin3_all (== 3)
_sizeof_moomin3_a   (== 1)
_sizeof_moomin3_b   (== 1)
_sizeof_moomin3_c   (== 1)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It is also possible to merge two or more sections using \fBAPPENDTO\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.RAMSECTION "RAMSection1" BANK 0 SLOT 0
label1    DB
\&.ENDS

\&.RAMSECTION "RAMSection2" APPENDTO "RAMSection1"
label2    DB
\&.ENDS
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
NOTE: When you have \fBRAMSECTION\fP s inside libraries, you must give
them BANKs and SLOTs in the linkfile, under [ramsections].
.sp
This is not a compulsory directive.
.SH .ENDS
.sp
Ends the section.
.sp
This is not a compulsory directive, but when \fB\&.SECTION\fP or \fB\&.RAMSECTION\fP
is used this one is required to terminate it.
.SH .ROMGBC
.sp
Inserts data into the specific ROM location to mark the ROM as a dual\-mode ROM
(\fB$80\fP \-> \fB$0143\fP, so ROM name is max. 15 characters long). It will run in
either DMG or GBC mode.
.sp
This is not a compulsory directive.
.SH .ROMGBCONLY
.sp
Inserts data into the specific ROM location to mark the ROM as a Gameboy Color
ROM (\fB$C0\fP \-> \fB$0143\fP, so ROM name is max. 15 characters long). It will
only run in GBC mode.
.sp
This is not a compulsory directive.
.SH .ROMDMG
.sp
Inserts data into the specific ROM location to mark the ROM as a DMG
(Gameboy) ROM (\fB$00\fP \-> \fB$0146\fP). It will only run in DMG mode.
.sp
This is not a compulsory directive. \fB\&.ROMDMG\fP cannot be used with \fB\&.ROMSGB\fP\&.
.SH .ROMSGB
.sp
Inserts data into the specific ROM location to mark the ROM as a Super
Gameboy enhanced ROM (\fB$03\fP \-> \fB$0146\fP).
.sp
This is not a compulsory directive. \fB\&.ROMSGB\fP cannot be used with \fB\&.ROMDMG\fP\&.
.SH .EXPORT WORK_X
.sp
Exports the definition \fBwork_x\fP to outside world. Exported definitions are
visible to all object files and libraries in the linking procedure. Note
that you can only export value definitions, not string definitions.
.sp
You can export as many definitions as you wish with one \fB\&.EXPORT\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.EXPORT NUMBER, NAME, ADDRESS, COUNTRY
\&.EXPORT NAME, AGE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .PRINT "NUMBERS 1 AND 10: ", DEC 1, " $", HEX 10, "\N"
.sp
Prints strings and numbers to stdout. A combination and a more usable version
of .PRINTT and .PRINTV. Useful for debugging.
.sp
Optional: Give \fBDEC\fP (decimal) or \fBHEX\fP (hexadecimal) before the value you
want to print.
.sp
This is not a compulsory directive.
.SH .PRINTT "HERE WE ARE...\N"
.sp
Prints the given text into stdout. Good for debugging stuff. \fBPRINTT\fP takes
only a string as argument, and the only supported formatting symbol is \fB\en\fP
(line feed).
.sp
This is not a compulsory directive.
.SH .PRINTV DEC DEBUG+1
.sp
Prints the value of the supplied definition or computation into stdout.
Computation must be solvable at the time of printing (just like definitions
values). \fBPRINTV\fP takes max two parameters. The first describes the type of the
print output. \fBDEC\fP means decimal, \fBHEX\fP means hexadecimal. This is optional.
Default is \fBDEC\fP\&.
.sp
Use \fBPRINTV\fP with \fBPRINTT\fP as \fBPRINTV\fP doesn\(aqt print linefeeds, only the
result. Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.PRINTT "Value of \e"DEBUG\e" = $"
\&.PRINTV HEX DEBUG
\&.PRINTT "\en"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is not a compulsory directive.
.SH .OUTNAME "OTHER.O"
.sp
Changes the name of the output file. Here\(aqs and example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wla\-gb \-o test.o test.s
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
would normally output \fBtest.o\fP, but if you had written
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.OUTNAME "new.o"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
somewhere in the code WLA would write the output to \fBnew.o\fP instead.
.sp
This is not a compulsory directive.
.SH .SNESHEADER
.sp
This begins the SNES header definition, and automatically defines
\fB\&.COMPUTESNESCHECKSUM\fP\&. From here you may define any of the following:
.INDENT 0.0
.IP \(bu 2
\fBID "ABCD"\fP \- inserts a one to four letter string starting at \fB$7FB2\fP
(lorom) or \fB$FFB2\fP (hirom).
.IP \(bu 2
\fBNAME "Hello World!"\fP \- identical to a freestanding \fB\&.NAME\fP\&.
.IP \(bu 2
\fBLOROM\fP \- identical to a freestanding \fB\&.LOROM\fP\&.
.IP \(bu 2
\fBHIROM\fP \- identical to a freestanding \fB\&.HIROM\fP\&.
.IP \(bu 2
\fBEXHIROM\fP \- identical to a freestanding \fB\&.EXHIROM\fP\&.
.IP \(bu 2
\fBSLOWROM\fP \- identical to a freestanding \fB\&.SLOWROM\fP\&.
.IP \(bu 2
\fBFASTROM\fP \- identical to a freestanding \fB\&.FASTROM\fP\&.
.IP \(bu 2
\fBCARTRIDGETYPE $00\fP \- Places the given 8\-bit value in \fB$7FD6\fP (\fB$FFD6\fP
in HiROM, \fB$40FFD6\fP and \fB$FFD6\fP in ExHiROM). Some possible values I\(aqve
come across but cannot guarantee the accuracy of:
.INDENT 2.0
.INDENT 3.5
.TS
center;
|l|l|l|l|.
_
T{
\fB$00\fP
T}	T{
ROM
T}	T{
T}	T{
T}
_
T{
\fB$01\fP
T}	T{
ROM
T}	T{
RAM
T}	T{
T}
_
T{
\fB$02\fP
T}	T{
ROM
T}	T{
SRAM
T}	T{
T}
_
T{
\fB$03\fP
T}	T{
ROM
T}	T{
T}	T{
DSP1
T}
_
T{
\fB$04\fP
T}	T{
ROM
T}	T{
RAM
T}	T{
DSP1
T}
_
T{
\fB$05\fP
T}	T{
ROM
T}	T{
SRAM
T}	T{
DSP1
T}
_
T{
\fB$13\fP
T}	T{
ROM
T}	T{
T}	T{
Super FX
T}
_
.TE
.UNINDENT
.UNINDENT
.IP \(bu 2
\fBROMSIZE $09\fP \- Places the given 8\-bit value in \fB$7FD7\fP (\fB$FFD7\fP in
HiROM, \fB$40FFD7\fP and \fB$FFD7\fP in ExHiROM). Possible values include (but
may not be limited to):
.INDENT 2.0
.INDENT 3.5
.TS
center;
|l|l|.
_
T{
\fB$08\fP
T}	T{
2 Megabits
T}
_
T{
\fB$09\fP
T}	T{
4 Megabits
T}
_
T{
\fB$0A\fP
T}	T{
8 Megabits
T}
_
T{
\fB$0B\fP
T}	T{
16 Megabits
T}
_
T{
\fB$0C\fP
T}	T{
32 Megabits
T}
_
.TE
.UNINDENT
.UNINDENT
.IP \(bu 2
\fBSRAMSIZE $01\fP \- Places the given 2\-bit value into \fB$7FD8\fP (\fB$FFD8\fP in
HiROM, \fB$40FFD8\fP and \fB$FFD8\fP in ExHiROM). I believe these are the only possible
values:
.INDENT 2.0
.INDENT 3.5
.TS
center;
|l|l|.
_
T{
\fB$00\fP
T}	T{
0 kilobits
T}
_
T{
\fB$01\fP
T}	T{
16 kilobits
T}
_
T{
\fB$02\fP
T}	T{
32 kilobits
T}
_
T{
\fB$03\fP
T}	T{
64 kilobits
T}
_
.TE
.UNINDENT
.UNINDENT
.IP \(bu 2
\fBCOUNTRY $00\fP \- Places the given 8\-bit value into \fB$7FD9\fP (\fB$FFD9\fP in
HiROM, \fB$40FFD9\fP and \fB$FFD9\fP in ExHiROM). \fB$00\fP is Japan and \fB$01\fP is the
United States, and there several more for other regions that I cannot recall off
the top of my head.
.IP \(bu 2
\fBLICENSEECODE $00\fP \- Places the given 8\-bit value into \fB$7FDA\fP (\fB$FFDA\fP
in HiROM, \fB$40FFDA\fP and \fB$FFDA\fP in ExHiROM). You must find the legal values
yourself as there are plenty of them. ;)
.IP \(bu 2
\fBVERSION $01\fP \- Places the given 8\-bit value into \fB$7FDB\fP (\fB$FFDB\fP in
HiROM, \fB$40FFDB\fP and \fB$FFDB\fP in ExHiROM). This is supposedly interpreted as
version 1.byte, so a \fB$01\fP here would be version 1.01.
.UNINDENT
.sp
This is not a compulsory directive.
.SH .ENDSNES
.sp
This ends the SNES header definition.
.sp
This is not a compulsory directive, but when \fB\&.SNESHEADER\fP is used this
one is required to terminate it.
.SH .SNESNATIVEVECTOR
.sp
Begins definition of the native mode interrupt vector table.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SNESNATIVEVECTOR
COP    COPHandler
BRK    BRKHandler
ABORT  ABORTHandler
NMI    VBlank
UNUSED $0000
IRQ    IRQHandler
\&.ENDNATIVEVECTOR
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
These can be defined in any order, but they will be placed into
memory starting at \fB$7FE4\fP (\fB$FFE4\fP in HiROM, \fB$40FFE4\fP and \fB$FFE4\fP in
ExHiROM) in the order listed above. All the vectors default to \fB$0000\fP\&.
.sp
This is not a compulsory directive.
.SH .ENDNATIVEVECTOR
.sp
Ends definition of the native mode interrupt vector table.
.sp
This is not a compulsory directive, but when \fB\&.SNESNATIVEVECTOR\fP
is used this one is required to terminate it.
.SH .SNESEMUVECTOR
.sp
Begins definition of the emulation mode interrupt vector table.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.SNESEMUVECTOR
COP    COPHandler
UNUSED $0000
ABORT  BRKHandler
NMI    VBlank
RESET  Main
IRQBRK IRQBRKHandler
\&.ENDEMUVECTOR
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
These can be defined in any order, but they will be placed into
memory starting at \fB$7FF4\fP (\fB$FFF4\fP in HiROM, \fB$40FFF4\fP and \fB$FFF4\fP in
ExHiROM) in the order listed above. All the vectors default to \fB$0000\fP\&.
.sp
This is not a compulsory directive.
.SH .ENDEMUVECTOR
.sp
Ends definition of the emulation mode interrupt vector table.
.sp
This is not a compulsory directive, but when \fB\&.SNESEMUVECTOR\fP
is used this one is required to terminate it.
.SH .UNION NAME
.sp
Begins a "union". This can only be used in enums, ramsections, and structs.
.sp
When entering a union, the current address in the enum is saved, and the
following data is processed as normal. When the \fB\&.NEXTU\fP directive is
encountered, the address is reverted back to the start of the union. This allows
one to assign an area of memory to multiple labels.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ENUM $C000
    .UNION
        pos_lowbyte:  db
        pos_highbyte: db
        extra_word:   dw
    .NEXTU
        pos:          dw
    .ENDU
    after: db
\&.ENDE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This example is equivalent to:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE pos_lowbyte  $c000
\&.DEFINE pos_highbyte $c001
\&.DEFINE extra_word   $c002
\&.DEFINE pos          $c000
\&.DEFINE after        $c004
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The \fB\&.UNION\fP and \fB\&.NEXTU\fP commands can be given an argument to assign
a prefix to the labels that follow.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.ENUM $C000
    .UNION union1
        byte1: db
        byte2: db
    .NEXTU union2
        word1: dw
    .ENDU
\&.ENDE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This example is equivalent to:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DEFINE union1.byte1 $c000
\&.DEFINE union1.byte2 $c001
\&.DEFINE union2.word1 $c000
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Unions can be nested.
.SH .NEXTU NAME
.sp
Proceeds to the next entry in a union.
.SH .ENDU
.sp
Ends the current union.
.SH CASE SENSITIVITY
.sp
WLA is case sensitive, so be careful.
.SH COMMENTS
.sp
Comments begin with \fB;\fP or \fB*\fP and end along with the line. \fB;\fP can be
used anywhere, but \fB*\fP can be placed only at the beginning of a new line.
.sp
WLA supports also ANSI C style commenting. This means you can start a
multiline comment with \fB/*\fP and end it with \fB*/\fP\&.
.sp
What also is supported are C++ style comments. This means you can start a
comment with \fB//\fP\&.
.sp
You can also use \fB\&.ASM\fP and \fB\&.ENDASM\fP directives to skip characters. These
function much like ANSI C comments, but unlike the ANSI C comments these can be
nested.
.SH LABELS
.sp
Labels are ordinary strings (which can also end to a \fB:\fP). Labels starting
with \fB_\fP are considered to be local labels and do not show outside sections
where they were defined, or outside object files, if they were not defined
inside a section.
.sp
Here are few examples of different labels:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
VBI_IRQ:
VBI_IRQ2
_VBI_LOOP:
main:
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Labels starting with \fB@\fP are considered to be child labels. They can only be
referenced within the scope of their parent labels, unless the full name is
specified. When there is more than one \fB@\fP, the label is considered to be
a child of a child.
.sp
Here are some examples of child labels:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PARENT1:
@CHILD:
@@SUBCHILD

PARENT2:
@CHILD:
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is legal, since each of the \fB@CHILD\fP labels has a different parent.
You can specify a parent to be explicit, like so:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
jr PARENT1@CHILD@SUBCHILD
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that when you place \fB:\fP in front of the label string when referring to
it, you\(aqll get the bank number of the label, instead of the label\(aqs address.
Here\(aqs an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LD A, :LOOP
\&.BANK 2 SLOT 0
LOOP:
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here \fBLD A, :LOOP\fP will be replaced with \fBLD A, 2\fP as the label \fBLOOP\fP
is inside the bank number two.
.sp
When you are referring to a label and you are adding something to its address
(or subtracting, any arithmetics apply) the result will always be bytes.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.org 20
DATA:  .dw 100, 200, 300
       ld  a, DATA+1
              ^^^^^^ = r
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
So here the result \fBr\fP will be the address of \fBDATA\fP plus one, here 21.
Some x86 assemblers would give here \fB22\fP as the result \fBr\fP as \fBDATA\fP
points to an array or machine words, but WLA isn\(aqt that smart (and some people
including me think this is the better solution).
.sp
Note that each CPU WLA supports contains opcodes that either generate an
absolute reference or a relative reference to the given label. For example,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.org 20
DATA:  ld  a, DATA   ; DATA becomes 20 (absolute)
       jr  DATA      ; DATA becomes \-4 (relative)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Check out section 14 for the list of opcodes that generate relative references.
.sp
You can also use \fB\-\fP, \fB\-\-\fP, \fB\-\-\-\fP, \fB+\fP, \fB++\fP, \fB+++\fP, ... as
un\-named labels. Labels consisting of \fB\-\fP are meant for reverse jumps and
labels consisting of \fB+\fP are meant for forward jumps. You can reuse un\-named
labels as much as you wish inside your source code. Here\(aqs an example of this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
    dec e
    beq ++      ; jump \-> ?
    dec e
    beq +       ; jump \-> %
    ld d, 14
\-\-\- ld a, 10    ; !
\-\-  ld b, c     ; #
\-   dec b       ; *
    jp nz, \-    ; jump \-> *
    dec c
    jp nz, \-\-   ; jump \-> #
    dec d
    jp nz, \-\-\-  ; jump \-> !
    ld a, 20
\-   dec a       ; $
    jp nz, \-    ; jump \-> $
+   halt        ; %
++  nop         ; ?
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that \fB__\fP (that\(aqs two underline characters) serves also as a un\-named
label. You can refer to this label from both directions. Use \fB_b\fP when
you are jumping backwards and \fB_f\fP when you are jumping forwards label \fB__\fP\&.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
   dec e
   jp z, _f     ; jump \-> *
   dec e
__ ldi a, (hl)  ; *
   dec e
   jp nz, _b    ; jump \-> *
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBCAVEAT! CAVEAT! CAVEAT!\fP
.sp
The following code doesn\(aqt work as it would if WLA would determine the
distance lexically (but in practice it\(aqs WLALINK that does all the
calculations and sees only the preprocessed output of WLA):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.macro dummy
\-  dec a        ; #
   jp nz, \-     ; jump \-> #
\&.endm

   ...
\-  nop          ; *
   dummy
   dec e
   jp nz, \-     ; i\(aqd like to jump to *, but i\(aqll end up jumping
                ; to # as it\(aqs closest to me in the output WLA produces
                ; for WLALINK (so it\(aqs better to use \e@ with labels inside
                ; a macro).
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
WLALINK will also generate \fB_sizeof_[label]\fP defines that measure the
distance between two consecutive labels. These labels have the same scope as
the labels they describe. Here is an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Label1:
    .db 1, 2, 3, 4
Label2:
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In this case you\(aqll get a definition \fB_sizeof_Label1\fP that will have value
\fB4\fP\&.
.sp
WLA will skip over any child labels when calculating \fB_sizeof\fP\&. So, in this
example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Label1:
\&.db 1, 2
@child:
    .db 3, 4
Label2:
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The value of \fB_sizeof_Label1\fP will still have a value of \fB4\fP\&.
.SH NUMBER TYPES
.TS
center;
|l|l|.
_
T{
\fB1000\fP
T}	T{
decimal
T}
_
T{
\fB$100\fP
T}	T{
hexadecimal
T}
_
T{
\fB100h\fP
T}	T{
hexadecimal
T}
_
T{
\fB%100\fP
T}	T{
binary
T}
_
T{
\fB\(aqx\(aq\fP
T}	T{
character
T}
_
.TE
.sp
Remember that if you use the suffix \fBh\fP to give a hexadecimal value,
and the value begins with an alphabet, you must place a zero in front of it
so WLA knows it\(aqs not a label (e.g., \fB0ah\fP instead of \fBah\fP).
.SH STRINGS
.sp
Strings begin with and end to \fB"\fP\&. Note that no \fB0\fP is inserted to
indicate the termination of the string like in e.g., ANSI C. You\(aqll have to do
it yourself. You can place quotation marks inside strings the way C
preprocessors accept them.
.sp
Here are some examples of strings:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"Hello world!"
"He said: \e"Please, kiss me honey.\e""
.ft P
.fi
.UNINDENT
.UNINDENT
.SH MNEMONICS
.sp
You can give the operand size with the operand itself (and this is
highly recommended) in WLA 6502/65C02/6510/HUC6280/65816/6800/6801/6809:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
and #20.b
and #20.w
bit loop.b
bit loop.w
.ft P
.fi
.UNINDENT
.UNINDENT
.SH BRACKETS?
.sp
You can write
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LDI (HL), A
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LDI [HL], A
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
as both mean the same thing in the syntax of most of the supported CPUs.
Yes, you could write
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LDI [HL), A
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
but that is not recommended.
.sp
Note that brackets have special meaning when dealing with a 65816/SPC\-700
system so you can\(aqt use
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND [$65]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
instead of
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND ($65)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
as they mean different things.
.sp
There are quite a few of them in WLA, but most of them are not as informative
as I would like them to be. This will be fixed in the future. Mean while, be
careful. ;)
.SH ROM SIZE
.sp
GB\-Z80 version of WLA supports the following ROM bank sizes. There\(aqs no such
limit in the Z80/6502/65C02/6510/65816/6800/6801/6809/8008/8080/HUC6280/SPC\-700
version of WLA. Supply one of the following values to \fB\&.ROMBANKS\fP\&.
.TS
center;
|l|l|l|l|.
_
T{
\fB$00\fP
T}	T{
256Kbit
T}	T{
32KByte
T}	T{
2 banks
T}
_
T{
\fB$01\fP
T}	T{
512Kbit
T}	T{
64KByte
T}	T{
4 banks
T}
_
T{
\fB$02\fP
T}	T{
1Mbit
T}	T{
128KByte
T}	T{
8 banks
T}
_
T{
\fB$03\fP
T}	T{
2Mbit
T}	T{
256KByte
T}	T{
16 banks
T}
_
T{
\fB$04\fP
T}	T{
4Mbit
T}	T{
512KByte
T}	T{
32 banks
T}
_
T{
\fB$05\fP
T}	T{
8Mbit
T}	T{
1MByte
T}	T{
64 banks
T}
_
T{
\fB$06\fP
T}	T{
16Mbit
T}	T{
2MByte
T}	T{
128 banks
T}
_
T{
\fB$07\fP
T}	T{
32Mbit
T}	T{
4MByte
T}	T{
256 banks
T}
_
T{
\fB$08\fP
T}	T{
64Mbit
T}	T{
8MByte
T}	T{
512 banks
T}
_
T{
\fB$52\fP
T}	T{
9Mbit
T}	T{
1.1MByte
T}	T{
72 banks
T}
_
T{
\fB$53\fP
T}	T{
10Mbit
T}	T{
1.2MByte
T}	T{
80 banks
T}
_
T{
\fB$54\fP
T}	T{
12Mbit
T}	T{
1.5MByte
T}	T{
96 banks
T}
_
.TE
.SH RAM SIZE
.sp
Supply one of the following hex values to \fB\&.RAMSIZE\fP in the GB\-Z80 version
of WLA.
.TS
center;
|l|l|l|l|.
_
T{
\fB$00\fP
T}	T{
None
T}	T{
None
T}	T{
None
T}
_
T{
\fB$01\fP
T}	T{
16kbit
T}	T{
2kByte
T}	T{
1 bank
T}
_
T{
\fB$02\fP
T}	T{
64kbit
T}	T{
8kByte
T}	T{
1 bank
T}
_
T{
\fB$03\fP
T}	T{
256kbit
T}	T{
32kByte
T}	T{
4 banks
T}
_
T{
\fB$04\fP
T}	T{
1Mbit
T}	T{
128kByte
T}	T{
16 banks
T}
_
T{
\fB$05\fP
T}	T{
512kbit
T}	T{
64kByte
T}	T{
8 banks
T}
_
.TE
.SH CARTRIDGE TYPE
.sp
It\(aqs up to the user to check that the cartridge type is valid and
can be used combined with the supplied ROM and RAM sizes. Give
one the the following values to \fB\&.CARTRIDGETYPE\fP in the GB\-Z80 version of WLA.
.TS
center;
|l|l|l|l|l|l|l|.
_
T{
\fB$00\fP
T}	T{
ROM
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$01\fP
T}	T{
ROM
T}	T{
MBC1
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$02\fP
T}	T{
ROM
T}	T{
MBC1
T}	T{
RAM
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$03\fP
T}	T{
ROM
T}	T{
MBC1
T}	T{
RAM
T}	T{
BATTERY
T}	T{
T}	T{
T}
_
T{
\fB$05\fP
T}	T{
ROM
T}	T{
MBC2
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$06\fP
T}	T{
ROM
T}	T{
MBC2
T}	T{
T}	T{
BATTERY
T}	T{
T}	T{
T}
_
T{
\fB$08\fP
T}	T{
ROM
T}	T{
T}	T{
RAM
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$09\fP
T}	T{
ROM
T}	T{
T}	T{
RAM
T}	T{
BATTERY
T}	T{
T}	T{
T}
_
T{
\fB$0B\fP
T}	T{
ROM
T}	T{
MMM01
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$0C\fP
T}	T{
ROM
T}	T{
MMM01
T}	T{
SRAM
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$0D\fP
T}	T{
ROM
T}	T{
MMM01
T}	T{
SRAM
T}	T{
BATTERY
T}	T{
T}	T{
T}
_
T{
\fB$0F\fP
T}	T{
ROM
T}	T{
MBC3
T}	T{
T}	T{
BATTERY
T}	T{
TIMER
T}	T{
T}
_
T{
\fB$10\fP
T}	T{
ROM
T}	T{
MBC3
T}	T{
RAM
T}	T{
BATTERY
T}	T{
TIMER
T}	T{
T}
_
T{
\fB$11\fP
T}	T{
ROM
T}	T{
MBC3
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$12\fP
T}	T{
ROM
T}	T{
MBC3
T}	T{
RAM
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$13\fP
T}	T{
ROM
T}	T{
MBC3
T}	T{
RAM
T}	T{
BATTERY
T}	T{
T}	T{
T}
_
T{
\fB$19\fP
T}	T{
ROM
T}	T{
MBC5
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$1A\fP
T}	T{
ROM
T}	T{
MBC5
T}	T{
RAM
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$1B\fP
T}	T{
ROM
T}	T{
MBC5
T}	T{
RAM
T}	T{
BATTERY
T}	T{
T}	T{
T}
_
T{
\fB$1C\fP
T}	T{
ROM
T}	T{
MBC5
T}	T{
T}	T{
T}	T{
T}	T{
RUMBLE
T}
_
T{
\fB$1D\fP
T}	T{
ROM
T}	T{
MBC5
T}	T{
SRAM
T}	T{
T}	T{
T}	T{
RUMBLE
T}
_
T{
\fB$1E\fP
T}	T{
ROM
T}	T{
MBC5
T}	T{
SRAM
T}	T{
BATTERY
T}	T{
T}	T{
RUMBLE
T}
_
T{
\fB$20\fP
T}	T{
MBC6
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$22\fP
T}	T{
MBC7
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$BE\fP
T}	T{
Pocket Voice
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$FC\fP
T}	T{
Pocket Camera
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$FD\fP
T}	T{
Bandai TAMA5
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$FE\fP
T}	T{
Hudson HuC\-3
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
T{
\fB$FF\fP
T}	T{
Hudson HuC\-1
T}	T{
T}	T{
T}	T{
T}	T{
T}	T{
T}
_
.TE
.sp
If you find bugs, please let us know about them via GitHub:
\fI\%https://github.com/vhelin/wla\-dx/issues\fP
.SH EXAMPLES
.sp
The main purpose of the files in the \fBexamples\fP directory is to test that WLA
and WLALINK can assemble and link the tiny project correctly. You can also
take a look at the code and syntax in the files, but beware: if you run the
rom files you probably don\(aqt see anything on screen.
.sp
\fBinclude\fP directory under \fBgb\-z80\fP could be very useful as the six include
files there have all the Game Boy hardware register address and memory
definitions you could ever need and more.
.SH EXAMPLES/GB-Z80/LIB
.sp
This folder holds few very useful libraries for you to use in your Game Boy
projects. Instead of reinventing the wheel, use the stuff found in here.
Remember to compile the libraries right after you\(aqve installed WLA by
executing \fBmake\fP in the \fBlib\fP directory.
.SH MEMORYMAPS
.sp
Here you can find default memory maps (see \fB\&.MEMORYMAP\fP) for various computers
and video game consoles.
.sp
Note that WLA will generate an temporary files in the current working
directory while it works. On Windows and Unix\-like systems, the file is
called \fB\&.wla%PID%a\fP, where \fB%PID%\fP is the PID of the process.
For other system, it\(aqs just \fBwla_a.tmp\fP\&.
.sp
When WLA finishes its work these two files are deleted as they serve
of no further use.
.SH COMPILING OBJECT FILES
.sp
To compile an object file use the \fB\-o [OUT]\fP option on the command line.
.sp
These object files can be linked together (or with library files) later
with WLALINK.
.sp
Name object files so that they can be recognized as object files. Normal
suffix is \fB\&.o\fP (WLA default). This can also be changed with \fB\&.OUTNAME\fP\&.
.sp
With object files you can reduce the amount of compiling when editing
small parts of the program. Note also the possibility of using local
labels (starting with \fB_\fP).
.sp
\fBNote\fP: When you compile objects, group 1 directives are saved for linking
time, when they are all compared and if they differ, an error message is
shown. It is advisable to use something like an include file to hold all
the group 1 directives for that particular project and include it to every
object file.
.sp
If you are interested in the WLA object file format, take a look at the
file \fBtxt/wla_file_formats.txt\fP which is included in the release archive.
.sp
Here are some examples of definitions:
.INDENT 0.0
.IP \(bu 2
\fB\-D IEXIST\fP
.IP \(bu 2
\fB\-D DAY=10\fP
.IP \(bu 2
\fB\-D BASE = $10\fP
.IP \(bu 2
\fB\-D NAME=elvis\fP
.UNINDENT
.sp
And here\(aqs an WLA example creating definitions on the command line:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wla\-gb \-D DEBUG \-D VERBOSE=5 \-D NAME = "math v1.0" \-o math.o math.s
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBDEBUG\fP\(aqs value will be \fB0\fP, \fBVERBOSE\fP\(aqs \fB5\fP and \fBNAME\fP is a
string definition with value \fBmath v1.0\fP\&.
Note that \fB\-D\fP always needs a space after it, but the rest of the statement
can be optionally stuck inside one word.
.SH COMPILING LIBRARY FILES
.sp
To compile a library file use the \fB\-l [OUT]\fP option on the command line.
.sp
Name these files so that they can be recognized as library files. Normal
suffix is \fB\&.lib\fP (WLA default).
.sp
With library files you can reduce the amount of compiling. Library files
are meant to hold general functions that can be used in different projects.
Note also the possibility of using local labels (starting with \fB_\fP).
Library files consist only of \fBFREE\fP sections.
.sp
After you have produced one or more object files and perhaps some library
files, you might want to link them together to produce a ROM image / program
file. WLALINK is the program you use for that. Here\(aqs how you use it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wlalink [OPTIONS] <LINK FILE> <OUTPUT FILE>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Choose the option \fB\-b [OUT]\fP for program file or \fB\-r [OUT]\fP for
ROM image linking.
.sp
Link file is a text file that contains information about the files you want
to link together. Here\(aqs the format:
.INDENT 0.0
.IP 1. 3
You must define the group for the files. Put the name of the group
inside brackets. Valid group definitions are
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
[objects]
[libraries]
[header]
[footer]
[definitions]
[ramsections]
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 2. 3
Start to list the file names.
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
[objects]
main.o
vbi.o
level_01.o
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 3. 3
Give parameters to the library files:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
[libraries]
bank 0 slot 1 speed.lib
bank 4 slot 2 map_data.lib
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here you can also use \fBbase\fP to define the 65816 CPU bank number
(like \fB\&.BASE\fP works in WLA):
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
[libraries]
bank 0 slot 1 base $80 speed.lib
bank 4 slot 2 base $80 map_data.lib
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You must tell WLALINK the bank and the slot for the library files.
.IP 4. 3
If you want to use header and/or footer in your project,
you can type the following:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
[header]
header.dat
[footer]
footer.dat
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 5. 3
If you have RAMSECTIONs inside the libraries, you must place
the sections inside BANKs and SLOTs:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
[ramsections]
bank 0 slot 3 "library 1 vars 1"
bank 0 slot 3 "library 1 vars 2"
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 6. 3
If you want to make value definitions, here\(aqs your chance:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
[definitions]
debug 1
max_str_len 128
start $150
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If flag \fBv\fP is used, WLALINK displays information about ROM file after a
succesful linking.
.sp
If flag \fBs\fP is used, WLALINK will produce a NO$GMB/NO$SNES symbol file. It\(aqs
useful when you work under MSDOS (NO$GMB is a very good Game Boy emulator for
MSDOS/Windows) as it contains information about the labels in your project.
.sp
If flag \fBS\fP is used, WLALINK will create a WLA symbol file, that is much
like NO$GMB symbol file, but shows also symbols and breakpoints, not just labels
and definitions.
.sp
If flag \fBd\fP is used, WLALINK discards all unreferenced \fBFREE\fP, \fBSEMIFREE\fP,
\fBSEMISUBFREE\fP, \fBSUPERFREE\fP and \fBRAM\fP sections. This way you can link big
libraries to your project and WLALINK will choose only the used sections, so you
won\(aqt be linking any dead code/data.
.sp
If flag \fBi\fP is given, WLALINK will write list files. Note that you must
compile the object and library files with \fB\-i\fP flag as well. Otherwise
WLALINK has no extra information it needs to build list files. Here is an
example of a list file: Let\(aqs assume you\(aqve compiled a source file called
\fBmain.s\fP using the \fBi\fP flag. After you\(aqve linked the result also with the
\fBi\fP flag WLALINK has created a list file called \fBmain.lst\fP\&. This file
contains the source text and the result data the source compiled into. List
files are good for debugging. NOTE: list file data can currently be generated
only for code inside sections. \fB\&.MACRO\fP calls and \fB\&.REPT\fP s don\(aqt produce
list file data either.
.sp
If flag \fBL\fP is given after the above options, WLALINK will use the
directory specified after the flag for including libraries. If WLALINK
cannot find the library in the specified directory, it will then silently
search the current working directory. This is useful when using WLA in an SDK
environment where a global path is needed.
.sp
Make sure you don\(aqt create duplicate labels in different places in the
memory map as they break the linking loop. Duplicate labels are allowed when
they overlap each other in the destination machine\(aqs memory. Look at the
following example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&...
\&.BANK 0
\&.ORG $150

    ...
    LD      A, 1
    CALL    LOAD_LEVEL
    ...

LOAD_LEVEL:
    LD      HL, $2000
    LD      (HL), A
    CALL    INIT_LEVEL
    RET

\&.BANK 1
\&.ORG 0

INIT_LEVEL:
    ...
    RET

\&.BANK 2
\&.ORG $0

INIT_LEVEL:
    ...
    RET
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here duplicate \fBINIT_LEVEL\fP labels are accepted as they both point to the
same memory address (in the program\(aqs point of view).
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[seravy@localhost tbp]# wlalink \-r linkfile testa.sfc
[seravy@localhost tbp]# wlalink \-d \-i \-b linkfile testb.sfc
[seravy@localhost tbp]# wlalink \-v \-S \-L ../../lib linkfile testc.sfc
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
WLA is able to solve really complex calculations like
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\-((HELLO / 2) | 3)
skeletor_end\-skeletor
10/2.5
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
so you can write something like
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LD HL, data_end\-data
LD A, (pointer + 1)
CP (TEST + %100) & %10101010
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
WLALINK also has this ability so it can compute the pending calculations
WLA wasn\(aqt able to solve.
.sp
The following operators are valid:
.TS
center;
|l|l|.
_
T{
\fB,\fP
T}	T{
comma
T}
_
T{
\fB|\fP
T}	T{
or
T}
_
T{
\fB&\fP
T}	T{
and
T}
_
T{
\fB^\fP
T}	T{
power
T}
_
T{
\fB<<\fP
T}	T{
shift left
T}
_
T{
\fB>>\fP
T}	T{
shift right
T}
_
T{
\fB+\fP
T}	T{
plus
T}
_
T{
\fB\-\fP
T}	T{
minux
T}
_
T{
\fB#\fP
T}	T{
modulo
T}
_
T{
\fB~\fP
T}	T{
xor
T}
_
T{
\fB*\fP
T}	T{
multiply
T}
_
T{
\fB/\fP
T}	T{
divide
T}
_
T{
\fB<\fP
T}	T{
get the low byte
T}
_
T{
\fB>\fP
T}	T{
get the high byte
T}
_
.TE
.sp
Note that you can do NOT using XOR:
.INDENT 0.0
.IP \(bu 2
\fBVALUE_A ~ $FF\fP   is  8\-bit NOT
.IP \(bu 2
\fBVALUE_B ~ $FFFF\fP is 16\-bit NOT
.UNINDENT
.sp
Unary XOR (e.g., \fB~$FF\fP) is the same as NOT.
.sp
WLA computes internally with real numbers so \fB(5/2)*2\fP produces \fB5\fP,
not \fB4\fP\&.
.sp
WLAB converts binary files to WLA\(aqs byte definition strings. Here\(aqs how
you use it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wlab \-[ap]{bdh} <BIN FILE>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Give it the binary file and WLAB will output the WLA DB formatted data of it
into stdout. Here\(aqs an example from real life:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wlab \-da gayskeletor.bin > gayskeletor.s
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
WLAB has three command flags of which one must be given to WLAB:
.INDENT 0.0
.TP
.B \-b
Output data in binary format.
.TP
.B \-d
Output data in decimal format.
.TP
.B \-h
Output data in hexadecimal format.
.UNINDENT
.sp
WLAB has also two option flags:
.INDENT 0.0
.TP
.B \-a
Print the address (relative to the beginning of the data).
.TP
.B \-p
Don\(aqt print file header.
.UNINDENT
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[seravy@localhost src]# wlab \-bap iscandar.bin > iscandar.s
[seravy@localhost src]# wlab \-h starsha.bin > starsha.s
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Please check out the source code examples (in \fBexamples\fP directory) for
quick target system specific information.
.SH Z80
.sp
Check the Z80 specific directives. All SMS/GG coders should find \fB\&.SMSTAG\fP,
\fB\&.SDSCTAG\fP and \fB\&.COMPUTESMSCHECKSUM\fP very useful...
.sp
There are shadow register aliases for opcodes that use registers A, F, BC, DE and HL.
The shadow register versions are just for convenience, if the programmer wants to
explicitly show that he is now using the shadow registers. For example:
.INDENT 0.0
.INDENT 3.5
AND A     ; (original, assembles to 0xA7)
AND A\(aq    ; (alias, assembles to 0xA7 and is in reality "AND A")
.UNINDENT
.UNINDENT
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
JR *
DJNZ
.ft P
.fi
.UNINDENT
.UNINDENT
.SH 6502
.sp
For example mnemonics \fBADC\fP, \fBAND\fP, \fBASL\fP, etc... cause problems to WLA,
because they take different sized arguments. Take a look at this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11       ; $46 $0B
LSR $A000    ; $4E $00 $A0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The first one could also be
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11       ; $4E $0B $00
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To really get what you want, use \fB\&.8BIT\fP, \fB\&.16BIT\fP and \fB\&.24BIT\fP
directives. Or even better, supply WLA the size of the argument:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LSR 11.W     ; $4E $0B $00
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
BCC
BCS
BEQ
BMI
BNE
BPL
BVC
BVS
.ft P
.fi
.UNINDENT
.UNINDENT
.SH 65C02
.sp
Read the subsection \fI\%6502\fP as the information applies also to 65C02
coding...
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
BCC
BCS
BEQ
BMI
BNE
BPL
BVC
BVS
BRA
BBR*
BBS*
.ft P
.fi
.UNINDENT
.UNINDENT
.SH 6510
.sp
Read the subsection \fI\%6502\fP as the information applies also to 6510
coding...
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
BCC
BCS
BEQ
BMI
BNE
BPL
BVC
BVS
.ft P
.fi
.UNINDENT
.UNINDENT
.SH 65816
.sp
Read the subsection \fI\%6502\fP as the information applies also to 65816
coding...
.sp
WLA\-65816 has also few SNES specific directives which are all very
helpful. Remember that when you use \fB\&.LOROM\fP, \fB\&.HIROM\fP, \fB\&.SLOWROM\fP and
\fB\&.FASTROM\fP WLA automatically writes the information into the output.
\fB\&.COMPUTESNESCHECKSUM\fP, \fB\&.SNESHEADER\fP and few others could also be useful.
.sp
Use \fB\&.BASE\fP to set the upmost eight bits of 24\-bit addresses.
.sp
If possible, use operand hints to specify the size of the operand.
WLA is able to deduce the accumulator/index mode to some extent from
\fBREP\fP/\fBSEP\fP\-mnemonics and \fB\&.ACCU\fP and \fB\&.INDEX\fP\-directives, but just to
be sure, terminate the operand with \fB\&.B\fP, \fB\&.W\fP or \fB\&.L\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND #10     ; can be two different things, depending on the size of the accu.
AND #10.B   ; forces 8\-bit immediate value.
AND #10.W   ; forces 16\-bit immediate value.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or if you must, these work as well:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
AND.B #10   ; the same as "AND #10.B".
AND.W #10   ; the same as "AND #10.W".
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
BCC
BCS
BEQ
BMI
BNE
BPL
BVC
BVS
BRA
BRL
PER
.ft P
.fi
.UNINDENT
.UNINDENT
.SH HUC6280
.sp
Read the subsection \fI\%6502\fP as the information applies also to
HUC6280 coding...
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
BCC
BCS
BEQ
BMI
BNE
BPL
BVC
BVS
BSR
BBR*
BBS*
.ft P
.fi
.UNINDENT
.UNINDENT
.SH SPC-700
.sp
Note that you\(aqll have to put an exclamation mark before a 16\-bit value.
For example,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
CALL !Main
AND  A, !$1000
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
BCC
BCS
BEQ
BMI
BNE
BPL
BVC
BVS
BRA
BBS
BBC
CBNE *
DBNZ *
.ft P
.fi
.UNINDENT
.UNINDENT
.SH POCKET VOICE (GB-Z80)
.sp
Pocket Voice uses its own MBC. You can enable Pocket Voice mode by selecting
Pocket Voice cartridge type (\fB$BE\fP in \fB$0147\fP) and defining correct
\fB\&.ROMBANKMAP\fP and \fB\&.MEMORYMAP\fP\&. In PV mode bank 0 is 24KB and the rest are
8KB.
.sp
Note that WLA assumes that ROM offset is all the time 0. If you use
something else as the offset, make sure to compute the jumps by hand as WLA
cannot do that.
.sp
Check out \fBexamples/gb\-z80/include/pocket_voice.i\fP for more information.
.SH GB-Z80
.sp
WLA outputs only \fB$10\fP when it decodes \fBSTOP\fP\&. Often it\(aqs necessary to put
an extra \fBNOP\fP (\fB$00\fP) after a \fBSTOP\fP, and sometimes something else, but
that\(aqs left entirely to the user.
.sp
Opcodes that make relative label references:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
JR *
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here are short descriptions for the flags you can give to WLA:
.sp
You can supply WLA with some (or all or none) of the following option flags.
.INDENT 0.0
.TP
.B \-i
Add list file information. Adds extra information to the output so
WLALINK can produce list files.
.TP
.B \-M
WLA generates makefile rules describing the dependencies of the main
source file. Use only with flags \fBo\fP and \fBl\fP\&.
.TP
.B \-q
Quiet mode. \fB\&.PRINT*\fP \-directives output nothing.
.TP
.B \-t
Test compile. Doesn\(aqt output any files.
.TP
.B \-v
Verbose mode. Shows a lot of information about the compiling process.
.TP
.B \-x
Extra compile time labels & definitions. WLA does extra work by creating
few helpful definitions, and labels SECTIONSTART_[section name] and
SECTIONEND_[section name] at the beginning and end of a section.
.TP
.B \-D
Declare a definition.
.UNINDENT
.sp
One (and only one) of the following command flags must be defined.
.INDENT 0.0
.TP
.B \-l
Output a library file.
.TP
.B \-o
Output an object file.
.UNINDENT
.sp
You may also use an extra option to specify the include directory. WLA will
search this directory for included files before defaulting to the specified
\fB\&.INCDIR\fP or current working directory.
.INDENT 0.0
.TP
.B \-I
Directory to include files.
.UNINDENT
.sp
Examples:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[seravy@localhost tbp]# wla \-D VERSION=255 \-x \-v \-i \-o testa.o testa.s
[seravy@localhost tbp]# wla \-M \-o testa.o testa.s
[seravy@localhost tbp]# wla \-D VERSION=$FF \-D MESSAGE=\e"Hello world\e" \-l testb.lib testb.s
[seravy@localhost tbp]# wla \-I ../../include \-l testb.lib testb.s
[seravy@localhost tbp]# wla \-M \-I myfiles \-l testa.lib testa.s
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that the first example produces file named \fBtesta.o\fP\&.
.sp
When you supply WLA with the flag \fBx\fP it will maintain few useful definitions
and labels while compiling your source codes. Please use the enhanced error
reporting engine (so don\(aqt use flag \fBf\fP) in conjunction with flag \fBx\fP as
some of the definitions require extra information about the flow of the data
which isn\(aqt available when using the old, crippled error reporting engine.
.sp
Here\(aqs a list of definitions you get when you use flag \fBx\fP:
.TS
center;
|l|l|.
_
T{
\fBWLA_FILENAME\fP
T}	T{
A string definition holding the file name WLA is
currently processing.
T}
_
T{
\fBWLA_TIME\fP
T}	T{
A string definition holding the calendar time
(obtained using C\(aqs \fBctime()\fP).
T}
_
T{
\fBWLA_VERSION\fP
T}	T{
A string definition holding the version number of WLA.
T}
_
.TE
.sp
So you can do for example something like
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.DB WLA_TIME
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
to store the time when the build process started into the ROM file you
are compiling.
.sp
Definition \fBCADDR\fP, which is present without supplying the flag \fBx\fP,
contains the current 16\-bit memory address. So
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
LD HL, CADDR
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
will load the address of the operand data into registers \fBH\fP and \fBL\fP\&.
.sp
\fBCAVEAT\fP:
Remember when using defines that \fBCADDR\fP gets the address of the place where
the definition is used, not the address of the definition, which contains
the \fBCADDR\fP\&.
.sp
Note that you\(aqll also get all these definitions in lower case
(e.g., \fBwla_filename\fP).
.sp
But that is not all. You will also get SECTIONSTART_[section name] labels
that are inserted into the start of every section, and SECTIONEND_[section name]
labels that are inserted into the end of every section.
.INDENT 0.0
.IP \(bu 2
Is 255 bytes too little for a string (file names, labels, definition labels,
etc)? Check out \fBMAX_NAME_LENGTH\fP in \fBshared.h\fP\&.
.IP \(bu 2
WLA preprocessor doesn\(aqt expand macros and repetitions. Those are actually
traversed in the assembling phase.
.IP \(bu 2
WLA\(aqs source code is mainly a huge mess, but WLALINK is quite well
structured and written. So beware!
.IP \(bu 2
To get the length of a string e.g. "peasoup", write "peasoup".length.
.IP \(bu 2
Do not write \fB\&.E\fP into your sources as WLA uses it internally to mark
the end of a file.
.UNINDENT
.sp
The two most important executables inside WLA DX are WLA (the assembler)
and WLALINK (the linker).
.SH WLA
.sp
WLA has four separate phases, called a little bit incorrectly passes:
.INDENT 0.0
.IP 1. 3
\fBpass_1.c\fP: \fBpass_1()\fP:
.INDENT 3.0
.IP \(bu 2
The biggest data processor in WLA.
.IP \(bu 2
Includes the include files: every time time happens the file is read in,
white space is removed, lines formatted, etc.
.IP \(bu 2
Macros are processed along with directives
.IP \(bu 2
All textual data, code, etc. are transformed into WLA\(aqs internal byte
code that gets written into a tmp (TMP) file, and after this phase
the assembler or the linker has no idea of target CPU\(aqs opcodes \- all is
just pure WLA byte code.
.IP \(bu 2
The first and the only pass that handles the assembly source files
supplied by the user.
.IP \(bu 2
The parser in this pass starts from the first byte of the first source
file, then moves forward parsing everything that it encounters, but
when a macro is called, the parser jumps to the beginning of the macro,
and continues parsing from there.
.UNINDENT
.IP 2. 3
\fBpass_2.c\fP: \fBpass_2()\fP:
.INDENT 3.0
.IP \(bu 2
If the user has issued directives like \fB\&.SDSCTAG\fP, here we generate the
needed data and write that into TMP.
.UNINDENT
.IP 3. 3
\fBpass_3.c\fP: \fBpass_3()\fP:
.INDENT 3.0
.IP \(bu 2
Here we read in TMP and do some sanity checks for the data, give labels
addresses (if possible), generate internal structures for labels and
sections.
.UNINDENT
.IP 4. 3
\fBpass_4.c\fP: \fBpass_4()\fP:
.INDENT 3.0
.IP \(bu 2
Again we read in TMP.
.IP \(bu 2
Now we check that if there is a reference to a calculation, and that
calculation has been succesfully calculated, then we can replace the
reference with the result.
.IP \(bu 2
This phase writes out object and library files, i.e., transforms TMP
to final output files (this write out could actually be \fBpass_5\fP)...
.UNINDENT
.UNINDENT
.SH WLALINK
.sp
WLALINK is much simpler and more straight forward than WLA; WLALINK just
reads in all the objects and library files, places the sections along with
labels into the target memory map, solves pending calculations, calculates
checksums, and writes out the final ROM/PRG files.
\fBwlalink/main.c:main()\fP should quite clearly display all the higher level
phases in the linking process.
.sp
Symbols can be optionally generated as a part of the assembly and link steps. With a compatible emulator, this can provide extra information for debugging a ROM, or otherwise help in understanding how it operates.
.sp
The symbols file can be generated by wlalink by adding "\-S" onto the command line. This will output labels, definitions, and some other rudimentary data. Most prominently, this can be used to understand where the ROM output various sections such as subroutines and data, and be able to look that up in the emulator\(aqs ROM or RAM space.
.sp
Extra information for address\-to\-line mapping can be provided by adding the following command line arguments:
\- Run object generation (e.g. "wla\-65816") with "\-i" to include list data in the output obj files
\- Run wlalink with "\-S \-A" to generate symbols with information related to address\-to\-line mapping
.sp
Address\-to\-line mappings includes information to relate lines in the source files to individual instructions in the generated ROM. This can be used to provide richer disassembly in the emulator, or allow for rich debugging in an external IDE.
.SH INFORMATION FOR EMULATOR DEVELOPERS
.sp
In order to properly support loading of WLA symbol files, it is recommended to follow this specification below, especially so as to gracefully support future additions to the symbol files.
.INDENT 0.0
.IP \(bu 2
The file should be read one line at a time
.IP \(bu 2
Any text on a line following a \fB;\fP should be ignored
.IP \(bu 2
Lines matching \fB\e[\eS+\e]\fP in regex or \fB[%s]\fP in scanf code are section headers, and represent a new section. Note that no section data will start with \fB[\fP\&.
.IP \(bu 2
Lines following the section header are the data for that section. If you\(aqre acknowledging the section, utilize that section\(aqs specific formatting. Read lines that match until a new section header is encountered.
.IP \(bu 2
Unless otherwise specified, none of the data in any section should be assumed to be sorted in any particular way.
.UNINDENT
.sp
The following are the list of currently supported sections, what they mean, and how their data should be interpreted.
.SS [labels]
.sp
This is a list of all Labels to sections of the ROM, such as subroutine locations, or data locations. Each line lists an address in hexadecimal (bank and offset) and a string associated with that address. This data could be used, for example, to identify what section a given target address is in, by searching for the label with the closest address less than the target address.
.INDENT 0.0
.IP \(bu 2
Regex match: \fB[0\-9a\-fA\-F]{2}:[0\-9a\-fA\-F]{4} .*\fP
.IP \(bu 2
Format specifier: \fB%2x:%4x %s\fP
.UNINDENT
.SS [definitions]
.sp
This is a list of various definitions provided in code \- or automatically during WLA\(aqs processing \- and values associated with them. Most prominently, WLA outputs the size of each section of the ROM. Each line lists an integer value in hexadecimal, and a string (name) associated with that value.
.INDENT 0.0
.IP \(bu 2
Regex match: \fB[0\-9a\-fA\-F]{8} .*\fP
.IP \(bu 2
Format specifier: \fB%8x %s\fP
.UNINDENT
.SS [breakpoints]
.sp
This is a list of hexadecimal ROM addresses where the \fB\&.BREAKPOINT\fP directive was used in the source assembly. Each line lists an address in hexadecimal (bank and offset).
.INDENT 0.0
.IP \(bu 2
Regex match: \fB[0\-9a\-fA\-F]{2}:[0\-9a\-fA\-F]{4}\fP
.IP \(bu 2
Format specificer: \fB%2x:%4x\fP
.UNINDENT
.SS [symbols]
.sp
This is a list of hexadecimal ROM addresses where the \fB\&.SYMBOL\fP directive was used in the source assembly. Each line lists an address in hexadecimal (bank and offset) and a string associated with that address.
.INDENT 0.0
.IP \(bu 2
Regex match: \fB[0\-9a\-fA\-F]{2}:[0\-9a\-fA\-F]{4} .*\fP
.IP \(bu 2
Format specifier: \fB%2x:%4x %s\fP
.UNINDENT
.SS [source files]
.sp
These are used to identify what files were used during the assembly process, especially to map generated assembly back to source file contents. Each line lists a hexadecimal file index, a hexadecimal CRC32 checksum of the file, and a file path relative to the generated ROM\(aqs root. This could be used to load in the contents of one of the input files when running the ROM and verifying the file is up\-to\-date by checking its CRC32 checksum against the one generated during assembly.
.INDENT 0.0
.IP \(bu 2
Regex match: \fB[0\-9a\-fA\-F]{4} [0\-9a\-fA\-F]{8} .*\fP
.IP \(bu 2
Format specifier: \fB%4x %8x %s\fP
.UNINDENT
.SS [rom checksum]
.sp
This is just a single line identifying what the hexadecimal CRC32 checksum of the ROM file was when the symbol file was generated. This could be used to verify that the symbol file itself is up\-to\-date with the ROM in question. This checksum is calculated by reading the ROM file\(aqs entire binary, and not by reading any platform\-specific checksum value embedded in the ROM itself.
.INDENT 0.0
.IP \(bu 2
Regex match:  \fB[0\-9a\-fA\-F]{8}\fP
.IP \(bu 2
Format specifier: \fB%8x\fP
.UNINDENT
.SS [addr\-to\-line mapping]
.sp
This is a listing of hexadecimal ROM addresses (bank and offset) each mapped to a hexadecimal file index and hexadecimal line index. The file index refers back to the file indices specified in the \fBsource files\fP section, so that the source file name can be discovered. This information can be used to, for example, display source file information in line with disassembled code, or to communicate with an external text editor the location of the current Program Counter by specifying a source file and line instead of some address in the binary ROM file.
.INDENT 0.0
.IP \(bu 2
Regex match: \fB[0\-9a\-fA\-F]{2}:[0\-9a\-fA\-F]{4} [0\-9a\-fA\-F]{4}:[0\-9a\-fA\-F]{8}\fP
.IP \(bu 2
Format specifier: \fB%2x:%4x %4x:%8x\fP
.UNINDENT
.sp
WLA DX (the whole package) was originally written by Ville Helin in 1998\-2008.
After that everybody has been able to take part in the development of WLA DX,
and recently via GitHub. The authors are not responsible for anything the
software does.
.sp
WLA DX is GPL software. For more information about GPL, take a look at the
\fBLICENCE\fP file.
.sp
Game Boy and Game Boy Color are copyrighted by Nintendo.
.sp
Pocket Voice is copyrighted by Bung HK.
.SH AUTHOR
vhelin
.SH COPYRIGHT
2019, vhelin
.\" Generated by docutils manpage writer.
.
